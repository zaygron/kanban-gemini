"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dnd-kit+sortable@8.0.0_@dnd-kit+core@6.3.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1";
exports.ids = ["vendor-chunks/@dnd-kit+sortable@8.0.0_@dnd-kit+core@6.3.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1"];
exports.modules = {

/***/ "(ssr)/../../node_modules/.pnpm/@dnd-kit+sortable@8.0.0_@dnd-kit+core@6.3.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/@dnd-kit/sortable/dist/sortable.esm.js":
/*!******************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@dnd-kit+sortable@8.0.0_@dnd-kit+core@6.3.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/@dnd-kit/sortable/dist/sortable.esm.js ***!
  \******************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SortableContext: () => (/* binding */ SortableContext),\n/* harmony export */   arrayMove: () => (/* binding */ arrayMove),\n/* harmony export */   arraySwap: () => (/* binding */ arraySwap),\n/* harmony export */   defaultAnimateLayoutChanges: () => (/* binding */ defaultAnimateLayoutChanges),\n/* harmony export */   defaultNewIndexGetter: () => (/* binding */ defaultNewIndexGetter),\n/* harmony export */   hasSortableData: () => (/* binding */ hasSortableData),\n/* harmony export */   horizontalListSortingStrategy: () => (/* binding */ horizontalListSortingStrategy),\n/* harmony export */   rectSortingStrategy: () => (/* binding */ rectSortingStrategy),\n/* harmony export */   rectSwappingStrategy: () => (/* binding */ rectSwappingStrategy),\n/* harmony export */   sortableKeyboardCoordinates: () => (/* binding */ sortableKeyboardCoordinates),\n/* harmony export */   useSortable: () => (/* binding */ useSortable),\n/* harmony export */   verticalListSortingStrategy: () => (/* binding */ verticalListSortingStrategy)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/.pnpm/next@14.1.0_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dnd-kit/core */ \"(ssr)/../../node_modules/.pnpm/@dnd-kit+core@6.3.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@dnd-kit/core/dist/core.esm.js\");\n/* harmony import */ var _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dnd-kit/utilities */ \"(ssr)/../../node_modules/.pnpm/@dnd-kit+utilities@3.2.2_react@18.3.1/node_modules/@dnd-kit/utilities/dist/utilities.esm.js\");\n\n\n\n/**\r\n * Move an array item to a different position. Returns a new array with the item moved to the new position.\r\n */ function arrayMove(array, from, to) {\n    const newArray = array.slice();\n    newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);\n    return newArray;\n}\n/**\r\n * Swap an array item to a different position. Returns a new array with the item swapped to the new position.\r\n */ function arraySwap(array, from, to) {\n    const newArray = array.slice();\n    newArray[from] = array[to];\n    newArray[to] = array[from];\n    return newArray;\n}\nfunction getSortedRects(items, rects) {\n    return items.reduce((accumulator, id, index)=>{\n        const rect = rects.get(id);\n        if (rect) {\n            accumulator[index] = rect;\n        }\n        return accumulator;\n    }, Array(items.length));\n}\nfunction isValidIndex(index) {\n    return index !== null && index >= 0;\n}\nfunction itemsEqual(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.length !== b.length) {\n        return false;\n    }\n    for(let i = 0; i < a.length; i++){\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction normalizeDisabled(disabled) {\n    if (typeof disabled === \"boolean\") {\n        return {\n            draggable: disabled,\n            droppable: disabled\n        };\n    }\n    return disabled;\n}\n// To-do: We should be calculating scale transformation\nconst defaultScale = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst horizontalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { rects, activeNodeRect: fallbackActiveRect, activeIndex, overIndex, index } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    const itemGap = getItemGap(rects, index, activeIndex);\n    if (index === activeIndex) {\n        const newIndexRect = rects[overIndex];\n        if (!newIndexRect) {\n            return null;\n        }\n        return {\n            x: activeIndex < overIndex ? newIndexRect.left + newIndexRect.width - (activeNodeRect.left + activeNodeRect.width) : newIndexRect.left - activeNodeRect.left,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: -activeNodeRect.width - itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: activeNodeRect.width + itemGap,\n            y: 0,\n            ...defaultScale\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale\n    };\n};\nfunction getItemGap(rects, index, activeIndex) {\n    const currentRect = rects[index];\n    const previousRect = rects[index - 1];\n    const nextRect = rects[index + 1];\n    if (!currentRect || !previousRect && !nextRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.left - (previousRect.left + previousRect.width) : nextRect.left - (currentRect.left + currentRect.width);\n    }\n    return nextRect ? nextRect.left - (currentRect.left + currentRect.width) : currentRect.left - (previousRect.left + previousRect.width);\n}\nconst rectSortingStrategy = (_ref)=>{\n    let { rects, activeIndex, overIndex, index } = _ref;\n    const newRects = arrayMove(rects, overIndex, activeIndex);\n    const oldRect = rects[index];\n    const newRect = newRects[index];\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\nconst rectSwappingStrategy = (_ref)=>{\n    let { activeIndex, index, rects, overIndex } = _ref;\n    let oldRect;\n    let newRect;\n    if (index === activeIndex) {\n        oldRect = rects[index];\n        newRect = rects[overIndex];\n    }\n    if (index === overIndex) {\n        oldRect = rects[index];\n        newRect = rects[activeIndex];\n    }\n    if (!newRect || !oldRect) {\n        return null;\n    }\n    return {\n        x: newRect.left - oldRect.left,\n        y: newRect.top - oldRect.top,\n        scaleX: newRect.width / oldRect.width,\n        scaleY: newRect.height / oldRect.height\n    };\n};\n// To-do: We should be calculating scale transformation\nconst defaultScale$1 = {\n    scaleX: 1,\n    scaleY: 1\n};\nconst verticalListSortingStrategy = (_ref)=>{\n    var _rects$activeIndex;\n    let { activeIndex, activeNodeRect: fallbackActiveRect, index, rects, overIndex } = _ref;\n    const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;\n    if (!activeNodeRect) {\n        return null;\n    }\n    if (index === activeIndex) {\n        const overIndexRect = rects[overIndex];\n        if (!overIndexRect) {\n            return null;\n        }\n        return {\n            x: 0,\n            y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,\n            ...defaultScale$1\n        };\n    }\n    const itemGap = getItemGap$1(rects, index, activeIndex);\n    if (index > activeIndex && index <= overIndex) {\n        return {\n            x: 0,\n            y: -activeNodeRect.height - itemGap,\n            ...defaultScale$1\n        };\n    }\n    if (index < activeIndex && index >= overIndex) {\n        return {\n            x: 0,\n            y: activeNodeRect.height + itemGap,\n            ...defaultScale$1\n        };\n    }\n    return {\n        x: 0,\n        y: 0,\n        ...defaultScale$1\n    };\n};\nfunction getItemGap$1(clientRects, index, activeIndex) {\n    const currentRect = clientRects[index];\n    const previousRect = clientRects[index - 1];\n    const nextRect = clientRects[index + 1];\n    if (!currentRect) {\n        return 0;\n    }\n    if (activeIndex < index) {\n        return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;\n    }\n    return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;\n}\nconst ID_PREFIX = \"Sortable\";\nconst Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    activeIndex: -1,\n    containerId: ID_PREFIX,\n    disableTransforms: false,\n    items: [],\n    overIndex: -1,\n    useDragOverlay: false,\n    sortedRects: [],\n    strategy: rectSortingStrategy,\n    disabled: {\n        draggable: false,\n        droppable: false\n    }\n});\nfunction SortableContext(_ref) {\n    let { children, id, items: userDefinedItems, strategy = rectSortingStrategy, disabled: disabledProp = false } = _ref;\n    const { active, dragOverlay, droppableRects, over, measureDroppableContainers } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDndContext)();\n    const containerId = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useUniqueId)(ID_PREFIX, id);\n    const useDragOverlay = Boolean(dragOverlay.rect !== null);\n    const items = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>userDefinedItems.map((item)=>typeof item === \"object\" && \"id\" in item ? item.id : item), [\n        userDefinedItems\n    ]);\n    const isDragging = active != null;\n    const activeIndex = active ? items.indexOf(active.id) : -1;\n    const overIndex = over ? items.indexOf(over.id) : -1;\n    const previousItemsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(items);\n    const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);\n    const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;\n    const disabled = normalizeDisabled(disabledProp);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (itemsHaveChanged && isDragging) {\n            measureDroppableContainers(items);\n        }\n    }, [\n        itemsHaveChanged,\n        items,\n        isDragging,\n        measureDroppableContainers\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        previousItemsRef.current = items;\n    }, [\n        items\n    ]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            activeIndex,\n            containerId,\n            disabled,\n            disableTransforms,\n            items,\n            overIndex,\n            useDragOverlay,\n            sortedRects: getSortedRects(items, droppableRects),\n            strategy\n        }), [\n        activeIndex,\n        containerId,\n        disabled.draggable,\n        disabled.droppable,\n        disableTransforms,\n        items,\n        overIndex,\n        droppableRects,\n        useDragOverlay,\n        strategy\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, {\n        value: contextValue\n    }, children);\n}\nconst defaultNewIndexGetter = (_ref)=>{\n    let { id, items, activeIndex, overIndex } = _ref;\n    return arrayMove(items, activeIndex, overIndex).indexOf(id);\n};\nconst defaultAnimateLayoutChanges = (_ref2)=>{\n    let { containerId, isSorting, wasDragging, index, items, newIndex, previousItems, previousContainerId, transition } = _ref2;\n    if (!transition || !wasDragging) {\n        return false;\n    }\n    if (previousItems !== items && index === newIndex) {\n        return false;\n    }\n    if (isSorting) {\n        return true;\n    }\n    return newIndex !== index && containerId === previousContainerId;\n};\nconst defaultTransition = {\n    duration: 200,\n    easing: \"ease\"\n};\nconst transitionProperty = \"transform\";\nconst disabledTransition = /*#__PURE__*/ _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n    property: transitionProperty,\n    duration: 0,\n    easing: \"linear\"\n});\nconst defaultAttributes = {\n    roleDescription: \"sortable\"\n};\n/*\r\n * When the index of an item changes while sorting,\r\n * we need to temporarily disable the transforms\r\n */ function useDerivedTransform(_ref) {\n    let { disabled, index, node, rect } = _ref;\n    const [derivedTransform, setDerivedtransform] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const previousIndex = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(index);\n    (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!disabled && index !== previousIndex.current && node.current) {\n            const initial = rect.current;\n            if (initial) {\n                const current = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getClientRect)(node.current, {\n                    ignoreTransform: true\n                });\n                const delta = {\n                    x: initial.left - current.left,\n                    y: initial.top - current.top,\n                    scaleX: initial.width / current.width,\n                    scaleY: initial.height / current.height\n                };\n                if (delta.x || delta.y) {\n                    setDerivedtransform(delta);\n                }\n            }\n        }\n        if (index !== previousIndex.current) {\n            previousIndex.current = index;\n        }\n    }, [\n        disabled,\n        index,\n        node,\n        rect\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (derivedTransform) {\n            setDerivedtransform(null);\n        }\n    }, [\n        derivedTransform\n    ]);\n    return derivedTransform;\n}\nfunction useSortable(_ref) {\n    let { animateLayoutChanges = defaultAnimateLayoutChanges, attributes: userDefinedAttributes, disabled: localDisabled, data: customData, getNewIndex = defaultNewIndexGetter, id, strategy: localStrategy, resizeObserverConfig, transition = defaultTransition } = _ref;\n    const { items, containerId, activeIndex, disabled: globalDisabled, disableTransforms, sortedRects, overIndex, useDragOverlay, strategy: globalStrategy } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);\n    const index = items.indexOf(id);\n    const data = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>({\n            sortable: {\n                containerId,\n                index,\n                items\n            },\n            ...customData\n        }), [\n        containerId,\n        customData,\n        index,\n        items\n    ]);\n    const itemsAfterCurrentSortable = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>items.slice(items.indexOf(id)), [\n        items,\n        id\n    ]);\n    const { rect, node, isOver, setNodeRef: setDroppableNodeRef } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDroppable)({\n        id,\n        data,\n        disabled: disabled.droppable,\n        resizeObserverConfig: {\n            updateMeasurementsFor: itemsAfterCurrentSortable,\n            ...resizeObserverConfig\n        }\n    });\n    const { active, activatorEvent, activeNodeRect, attributes, setNodeRef: setDraggableNodeRef, listeners, isDragging, over, setActivatorNodeRef, transform } = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.useDraggable)({\n        id,\n        data,\n        attributes: {\n            ...defaultAttributes,\n            ...userDefinedAttributes\n        },\n        disabled: disabled.draggable\n    });\n    const setNodeRef = (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.useCombinedRefs)(setDroppableNodeRef, setDraggableNodeRef);\n    const isSorting = Boolean(active);\n    const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);\n    const shouldDisplaceDragSource = !useDragOverlay && isDragging;\n    const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;\n    const strategy = localStrategy != null ? localStrategy : globalStrategy;\n    const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({\n        rects: sortedRects,\n        activeNodeRect,\n        activeIndex,\n        overIndex,\n        index\n    }) : null;\n    const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({\n        id,\n        items,\n        activeIndex,\n        overIndex\n    }) : index;\n    const activeId = active == null ? void 0 : active.id;\n    const previous = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        activeId,\n        items,\n        newIndex,\n        containerId\n    });\n    const itemsHaveChanged = items !== previous.current.items;\n    const shouldAnimateLayoutChanges = animateLayoutChanges({\n        active,\n        containerId,\n        isDragging,\n        isSorting,\n        id,\n        index,\n        items,\n        newIndex: previous.current.newIndex,\n        previousItems: previous.current.items,\n        previousContainerId: previous.current.containerId,\n        transition,\n        wasDragging: previous.current.activeId != null\n    });\n    const derivedTransform = useDerivedTransform({\n        disabled: !shouldAnimateLayoutChanges,\n        index,\n        node,\n        rect\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (isSorting && previous.current.newIndex !== newIndex) {\n            previous.current.newIndex = newIndex;\n        }\n        if (containerId !== previous.current.containerId) {\n            previous.current.containerId = containerId;\n        }\n        if (items !== previous.current.items) {\n            previous.current.items = items;\n        }\n    }, [\n        isSorting,\n        newIndex,\n        containerId,\n        items\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (activeId === previous.current.activeId) {\n            return;\n        }\n        if (activeId && !previous.current.activeId) {\n            previous.current.activeId = activeId;\n            return;\n        }\n        const timeoutId = setTimeout(()=>{\n            previous.current.activeId = activeId;\n        }, 50);\n        return ()=>clearTimeout(timeoutId);\n    }, [\n        activeId\n    ]);\n    return {\n        active,\n        activeIndex,\n        attributes,\n        data,\n        rect,\n        index,\n        newIndex,\n        items,\n        isOver,\n        isSorting,\n        isDragging,\n        listeners,\n        node,\n        overIndex,\n        over,\n        setNodeRef,\n        setActivatorNodeRef,\n        setDroppableNodeRef,\n        setDraggableNodeRef,\n        transform: derivedTransform != null ? derivedTransform : finalTransform,\n        transition: getTransition()\n    };\n    function getTransition() {\n        if (derivedTransform || // Or to prevent items jumping to back to their \"new\" position when items change\n        itemsHaveChanged && previous.current.newIndex === index) {\n            return disabledTransition;\n        }\n        if (shouldDisplaceDragSource && !(0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.isKeyboardEvent)(activatorEvent) || !transition) {\n            return undefined;\n        }\n        if (isSorting || shouldAnimateLayoutChanges) {\n            return _dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.CSS.Transition.toString({\n                ...transition,\n                property: transitionProperty\n            });\n        }\n        return undefined;\n    }\n}\nfunction normalizeLocalDisabled(localDisabled, globalDisabled) {\n    var _localDisabled$dragga, _localDisabled$droppa;\n    if (typeof localDisabled === \"boolean\") {\n        return {\n            draggable: localDisabled,\n            // Backwards compatibility\n            droppable: false\n        };\n    }\n    return {\n        draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,\n        droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable\n    };\n}\nfunction hasSortableData(entry) {\n    if (!entry) {\n        return false;\n    }\n    const data = entry.data.current;\n    if (data && \"sortable\" in data && typeof data.sortable === \"object\" && \"containerId\" in data.sortable && \"items\" in data.sortable && \"index\" in data.sortable) {\n        return true;\n    }\n    return false;\n}\nconst directions = [\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up,\n    _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left\n];\nconst sortableKeyboardCoordinates = (event, _ref)=>{\n    let { context: { active, collisionRect, droppableRects, droppableContainers, over, scrollableAncestors } } = _ref;\n    if (directions.includes(event.code)) {\n        event.preventDefault();\n        if (!active || !collisionRect) {\n            return;\n        }\n        const filteredContainers = [];\n        droppableContainers.getEnabled().forEach((entry)=>{\n            if (!entry || entry != null && entry.disabled) {\n                return;\n            }\n            const rect = droppableRects.get(entry.id);\n            if (!rect) {\n                return;\n            }\n            switch(event.code){\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Down:\n                    if (collisionRect.top < rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Up:\n                    if (collisionRect.top > rect.top) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Left:\n                    if (collisionRect.left > rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n                case _dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.KeyboardCode.Right:\n                    if (collisionRect.left < rect.left) {\n                        filteredContainers.push(entry);\n                    }\n                    break;\n            }\n        });\n        const collisions = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.closestCorners)({\n            active,\n            collisionRect: collisionRect,\n            droppableRects,\n            droppableContainers: filteredContainers,\n            pointerCoordinates: null\n        });\n        let closestId = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getFirstCollision)(collisions, \"id\");\n        if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {\n            closestId = collisions[1].id;\n        }\n        if (closestId != null) {\n            const activeDroppable = droppableContainers.get(active.id);\n            const newDroppable = droppableContainers.get(closestId);\n            const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n            const newNode = newDroppable == null ? void 0 : newDroppable.node.current;\n            if (newNode && newRect && activeDroppable && newDroppable) {\n                const newScrollAncestors = (0,_dnd_kit_core__WEBPACK_IMPORTED_MODULE_1__.getScrollableAncestors)(newNode);\n                const hasDifferentScrollAncestors = newScrollAncestors.some((element, index)=>scrollableAncestors[index] !== element);\n                const hasSameContainer = isSameContainer(activeDroppable, newDroppable);\n                const isAfterActive = isAfter(activeDroppable, newDroppable);\n                const offset = hasDifferentScrollAncestors || !hasSameContainer ? {\n                    x: 0,\n                    y: 0\n                } : {\n                    x: isAfterActive ? collisionRect.width - newRect.width : 0,\n                    y: isAfterActive ? collisionRect.height - newRect.height : 0\n                };\n                const rectCoordinates = {\n                    x: newRect.left,\n                    y: newRect.top\n                };\n                const newCoordinates = offset.x && offset.y ? rectCoordinates : (0,_dnd_kit_utilities__WEBPACK_IMPORTED_MODULE_2__.subtract)(rectCoordinates, offset);\n                return newCoordinates;\n            }\n        }\n    }\n    return undefined;\n};\nfunction isSameContainer(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    return a.data.current.sortable.containerId === b.data.current.sortable.containerId;\n}\nfunction isAfter(a, b) {\n    if (!hasSortableData(a) || !hasSortableData(b)) {\n        return false;\n    }\n    if (!isSameContainer(a, b)) {\n        return false;\n    }\n    return a.data.current.sortable.index < b.data.current.sortable.index;\n}\n //# sourceMappingURL=sortable.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BkbmQta2l0K3NvcnRhYmxlQDguMC4wX0BkbmQta2l0K2NvcmVANi4zLjFfcmVhY3QtZG9tQDE4LjMuMV9yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMV9fcmVhY3RAMTguMy4xL25vZGVfbW9kdWxlcy9AZG5kLWtpdC9zb3J0YWJsZS9kaXN0L3NvcnRhYmxlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdGO0FBQ2tGO0FBQ3JDO0FBRTdIOztDQUVDLEdBQ0QsU0FBU29CLFVBQVVDLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxFQUFFO0lBQ2hDLE1BQU1DLFdBQVdILE1BQU1JLEtBQUs7SUFDNUJELFNBQVNFLE1BQU0sQ0FBQ0gsS0FBSyxJQUFJQyxTQUFTRyxNQUFNLEdBQUdKLEtBQUtBLElBQUksR0FBR0MsU0FBU0UsTUFBTSxDQUFDSixNQUFNLEVBQUUsQ0FBQyxFQUFFO0lBQ2xGLE9BQU9FO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNELFNBQVNJLFVBQVVQLEtBQUssRUFBRUMsSUFBSSxFQUFFQyxFQUFFO0lBQ2hDLE1BQU1DLFdBQVdILE1BQU1JLEtBQUs7SUFDNUJELFFBQVEsQ0FBQ0YsS0FBSyxHQUFHRCxLQUFLLENBQUNFLEdBQUc7SUFDMUJDLFFBQVEsQ0FBQ0QsR0FBRyxHQUFHRixLQUFLLENBQUNDLEtBQUs7SUFDMUIsT0FBT0U7QUFDVDtBQUVBLFNBQVNLLGVBQWVDLEtBQUssRUFBRUMsS0FBSztJQUNsQyxPQUFPRCxNQUFNRSxNQUFNLENBQUMsQ0FBQ0MsYUFBYUMsSUFBSUM7UUFDcEMsTUFBTUMsT0FBT0wsTUFBTU0sR0FBRyxDQUFDSDtRQUV2QixJQUFJRSxNQUFNO1lBQ1JILFdBQVcsQ0FBQ0UsTUFBTSxHQUFHQztRQUN2QjtRQUVBLE9BQU9IO0lBQ1QsR0FBR0ssTUFBTVIsTUFBTUgsTUFBTTtBQUN2QjtBQUVBLFNBQVNZLGFBQWFKLEtBQUs7SUFDekIsT0FBT0Es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cUksZ0JBQWdCcEksSUFBSTtRQUM5QyxPQUFPO0lBQ1Q7SUFFQSxPQUFPRCxFQUFFb0csSUFBSSxDQUFDckMsT0FBTyxDQUFDNkMsUUFBUSxDQUFDbEUsV0FBVyxLQUFLekMsRUFBRW1HLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQzZDLFFBQVEsQ0FBQ2xFLFdBQVc7QUFDcEY7QUFFQSxTQUFTNEgsUUFBUXRLLENBQUMsRUFBRUMsQ0FBQztJQUNuQixJQUFJLENBQUNvSSxnQkFBZ0JySSxNQUFNLENBQUNxSSxnQkFBZ0JwSSxJQUFJO1FBQzlDLE9BQU87SUFDVDtJQUVBLElBQUksQ0FBQ21LLGdCQUFnQnBLLEdBQUdDLElBQUk7UUFDMUIsT0FBTztJQUNUO0lBRUEsT0FBT0QsRUFBRW9HLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQzZDLFFBQVEsQ0FBQ2xILEtBQUssR0FBR08sRUFBRW1HLElBQUksQ0FBQ3JDLE9BQU8sQ0FBQzZDLFFBQVEsQ0FBQ2xILEtBQUs7QUFDdEU7QUFFdVEsQ0FDdlEsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9AZG5kLWtpdCtzb3J0YWJsZUA4LjAuMF9AZG5kLWtpdCtjb3JlQDYuMy4xX3JlYWN0LWRvbUAxOC4zLjFfcmVhY3RAMTguMy4xX19yZWFjdEAxOC4zLjFfX3JlYWN0QDE4LjMuMS9ub2RlX21vZHVsZXMvQGRuZC1raXQvc29ydGFibGUvZGlzdC9zb3J0YWJsZS5lc20uanM/NzE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlUmVmLCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlRG5kQ29udGV4dCwgZ2V0Q2xpZW50UmVjdCwgdXNlRHJvcHBhYmxlLCB1c2VEcmFnZ2FibGUsIGNsb3Nlc3RDb3JuZXJzLCBnZXRGaXJzdENvbGxpc2lvbiwgZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycywgS2V5Ym9hcmRDb2RlIH0gZnJvbSAnQGRuZC1raXQvY29yZSc7XG5pbXBvcnQgeyB1c2VVbmlxdWVJZCwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgQ1NTLCB1c2VDb21iaW5lZFJlZnMsIGlzS2V5Ym9hcmRFdmVudCwgc3VidHJhY3QgfSBmcm9tICdAZG5kLWtpdC91dGlsaXRpZXMnO1xuXG4vKipcclxuICogTW92ZSBhbiBhcnJheSBpdGVtIHRvIGEgZGlmZmVyZW50IHBvc2l0aW9uLiBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGl0ZW0gbW92ZWQgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuICovXG5mdW5jdGlvbiBhcnJheU1vdmUoYXJyYXksIGZyb20sIHRvKSB7XG4gIGNvbnN0IG5ld0FycmF5ID0gYXJyYXkuc2xpY2UoKTtcbiAgbmV3QXJyYXkuc3BsaWNlKHRvIDwgMCA/IG5ld0FycmF5Lmxlbmd0aCArIHRvIDogdG8sIDAsIG5ld0FycmF5LnNwbGljZShmcm9tLCAxKVswXSk7XG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuLyoqXHJcbiAqIFN3YXAgYW4gYXJyYXkgaXRlbSB0byBhIGRpZmZlcmVudCBwb3NpdGlvbi4gUmV0dXJucyBhIG5ldyBhcnJheSB3aXRoIHRoZSBpdGVtIHN3YXBwZWQgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuICovXG5mdW5jdGlvbiBhcnJheVN3YXAoYXJyYXksIGZyb20sIHRvKSB7XG4gIGNvbnN0IG5ld0FycmF5ID0gYXJyYXkuc2xpY2UoKTtcbiAgbmV3QXJyYXlbZnJvbV0gPSBhcnJheVt0b107XG4gIG5ld0FycmF5W3RvXSA9IGFycmF5W2Zyb21dO1xuICByZXR1cm4gbmV3QXJyYXk7XG59XG5cbmZ1bmN0aW9uIGdldFNvcnRlZFJlY3RzKGl0ZW1zLCByZWN0cykge1xuICByZXR1cm4gaXRlbXMucmVkdWNlKChhY2N1bXVsYXRvciwgaWQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IHJlY3RzLmdldChpZCk7XG5cbiAgICBpZiAocmVjdCkge1xuICAgICAgYWNjdW11bGF0b3JbaW5kZXhdID0gcmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH0sIEFycmF5KGl0ZW1zLmxlbmd0aCkpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkSW5kZXgoaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4ICE9PSBudWxsICYmIGluZGV4ID49IDA7XG59XG5cbmZ1bmN0aW9uIGl0ZW1zRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpc2FibGVkKGRpc2FibGVkKSB7XG4gIGlmICh0eXBlb2YgZGlzYWJsZWQgPT09ICdib29sZWFuJykge1xuICAgIHJldHVybiB7XG4gICAgICBkcmFnZ2FibGU6IGRpc2FibGVkLFxuICAgICAgZHJvcHBhYmxlOiBkaXNhYmxlZFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGlzYWJsZWQ7XG59XG5cbi8vIFRvLWRvOiBXZSBzaG91bGQgYmUgY2FsY3VsYXRpbmcgc2NhbGUgdHJhbnNmb3JtYXRpb25cbmNvbnN0IGRlZmF1bHRTY2FsZSA9IHtcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5jb25zdCBob3Jpem9udGFsTGlzdFNvcnRpbmdTdHJhdGVneSA9IF9yZWYgPT4ge1xuICB2YXIgX3JlY3RzJGFjdGl2ZUluZGV4O1xuXG4gIGxldCB7XG4gICAgcmVjdHMsXG4gICAgYWN0aXZlTm9kZVJlY3Q6IGZhbGxiYWNrQWN0aXZlUmVjdCxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXgsXG4gICAgaW5kZXhcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGFjdGl2ZU5vZGVSZWN0ID0gKF9yZWN0cyRhY3RpdmVJbmRleCA9IHJlY3RzW2FjdGl2ZUluZGV4XSkgIT0gbnVsbCA/IF9yZWN0cyRhY3RpdmVJbmRleCA6IGZhbGxiYWNrQWN0aXZlUmVjdDtcblxuICBpZiAoIWFjdGl2ZU5vZGVSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBpdGVtR2FwID0gZ2V0SXRlbUdhcChyZWN0cywgaW5kZXgsIGFjdGl2ZUluZGV4KTtcblxuICBpZiAoaW5kZXggPT09IGFjdGl2ZUluZGV4KSB7XG4gICAgY29uc3QgbmV3SW5kZXhSZWN0ID0gcmVjdHNbb3ZlckluZGV4XTtcblxuICAgIGlmICghbmV3SW5kZXhSZWN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogYWN0aXZlSW5kZXggPCBvdmVySW5kZXggPyBuZXdJbmRleFJlY3QubGVmdCArIG5ld0luZGV4UmVjdC53aWR0aCAtIChhY3RpdmVOb2RlUmVjdC5sZWZ0ICsgYWN0aXZlTm9kZVJlY3Qud2lkdGgpIDogbmV3SW5kZXhSZWN0LmxlZnQgLSBhY3RpdmVOb2RlUmVjdC5sZWZ0LFxuICAgICAgeTogMCxcbiAgICAgIC4uLmRlZmF1bHRTY2FsZVxuICAgIH07XG4gIH1cblxuICBpZiAoaW5kZXggPiBhY3RpdmVJbmRleCAmJiBpbmRleCA8PSBvdmVySW5kZXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogLWFjdGl2ZU5vZGVSZWN0LndpZHRoIC0gaXRlbUdhcCxcbiAgICAgIHk6IDAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGVcbiAgICB9O1xuICB9XG5cbiAgaWYgKGluZGV4IDwgYWN0aXZlSW5kZXggJiYgaW5kZXggPj0gb3ZlckluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGFjdGl2ZU5vZGVSZWN0LndpZHRoICsgaXRlbUdhcCxcbiAgICAgIHk6IDAsXG4gICAgICAuLi5kZWZhdWx0U2NhbGVcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgLi4uZGVmYXVsdFNjYWxlXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRJdGVtR2FwKHJlY3RzLCBpbmRleCwgYWN0aXZlSW5kZXgpIHtcbiAgY29uc3QgY3VycmVudFJlY3QgPSByZWN0c1tpbmRleF07XG4gIGNvbnN0IHByZXZpb3VzUmVjdCA9IHJlY3RzW2luZGV4IC0gMV07XG4gIGNvbnN0IG5leHRSZWN0ID0gcmVjdHNbaW5kZXggKyAxXTtcblxuICBpZiAoIWN1cnJlbnRSZWN0IHx8ICFwcmV2aW91c1JlY3QgJiYgIW5leHRSZWN0KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYWN0aXZlSW5kZXggPCBpbmRleCkge1xuICAgIHJldHVybiBwcmV2aW91c1JlY3QgPyBjdXJyZW50UmVjdC5sZWZ0IC0gKHByZXZpb3VzUmVjdC5sZWZ0ICsgcHJldmlvdXNSZWN0LndpZHRoKSA6IG5leHRSZWN0LmxlZnQgLSAoY3VycmVudFJlY3QubGVmdCArIGN1cnJlbnRSZWN0LndpZHRoKTtcbiAgfVxuXG4gIHJldHVybiBuZXh0UmVjdCA/IG5leHRSZWN0LmxlZnQgLSAoY3VycmVudFJlY3QubGVmdCArIGN1cnJlbnRSZWN0LndpZHRoKSA6IGN1cnJlbnRSZWN0LmxlZnQgLSAocHJldmlvdXNSZWN0LmxlZnQgKyBwcmV2aW91c1JlY3Qud2lkdGgpO1xufVxuXG5jb25zdCByZWN0U29ydGluZ1N0cmF0ZWd5ID0gX3JlZiA9PiB7XG4gIGxldCB7XG4gICAgcmVjdHMsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb3ZlckluZGV4LFxuICAgIGluZGV4XG4gIH0gPSBfcmVmO1xuICBjb25zdCBuZXdSZWN0cyA9IGFycmF5TW92ZShyZWN0cywgb3ZlckluZGV4LCBhY3RpdmVJbmRleCk7XG4gIGNvbnN0IG9sZFJlY3QgPSByZWN0c1tpbmRleF07XG4gIGNvbnN0IG5ld1JlY3QgPSBuZXdSZWN0c1tpbmRleF07XG5cbiAgaWYgKCFuZXdSZWN0IHx8ICFvbGRSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IG5ld1JlY3QubGVmdCAtIG9sZFJlY3QubGVmdCxcbiAgICB5OiBuZXdSZWN0LnRvcCAtIG9sZFJlY3QudG9wLFxuICAgIHNjYWxlWDogbmV3UmVjdC53aWR0aCAvIG9sZFJlY3Qud2lkdGgsXG4gICAgc2NhbGVZOiBuZXdSZWN0LmhlaWdodCAvIG9sZFJlY3QuaGVpZ2h0XG4gIH07XG59O1xuXG5jb25zdCByZWN0U3dhcHBpbmdTdHJhdGVneSA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIGluZGV4LFxuICAgIHJlY3RzLFxuICAgIG92ZXJJbmRleFxuICB9ID0gX3JlZjtcbiAgbGV0IG9sZFJlY3Q7XG4gIGxldCBuZXdSZWN0O1xuXG4gIGlmIChpbmRleCA9PT0gYWN0aXZlSW5kZXgpIHtcbiAgICBvbGRSZWN0ID0gcmVjdHNbaW5kZXhdO1xuICAgIG5ld1JlY3QgPSByZWN0c1tvdmVySW5kZXhdO1xuICB9XG5cbiAgaWYgKGluZGV4ID09PSBvdmVySW5kZXgpIHtcbiAgICBvbGRSZWN0ID0gcmVjdHNbaW5kZXhdO1xuICAgIG5ld1JlY3QgPSByZWN0c1thY3RpdmVJbmRleF07XG4gIH1cblxuICBpZiAoIW5ld1JlY3QgfHwgIW9sZFJlY3QpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogbmV3UmVjdC5sZWZ0IC0gb2xkUmVjdC5sZWZ0LFxuICAgIHk6IG5ld1JlY3QudG9wIC0gb2xkUmVjdC50b3AsXG4gICAgc2NhbGVYOiBuZXdSZWN0LndpZHRoIC8gb2xkUmVjdC53aWR0aCxcbiAgICBzY2FsZVk6IG5ld1JlY3QuaGVpZ2h0IC8gb2xkUmVjdC5oZWlnaHRcbiAgfTtcbn07XG5cbi8vIFRvLWRvOiBXZSBzaG91bGQgYmUgY2FsY3VsYXRpbmcgc2NhbGUgdHJhbnNmb3JtYXRpb25cbmNvbnN0IGRlZmF1bHRTY2FsZSQxID0ge1xuICBzY2FsZVg6IDEsXG4gIHNjYWxlWTogMVxufTtcbmNvbnN0IHZlcnRpY2FsTGlzdFNvcnRpbmdTdHJhdGVneSA9IF9yZWYgPT4ge1xuICB2YXIgX3JlY3RzJGFjdGl2ZUluZGV4O1xuXG4gIGxldCB7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgYWN0aXZlTm9kZVJlY3Q6IGZhbGxiYWNrQWN0aXZlUmVjdCxcbiAgICBpbmRleCxcbiAgICByZWN0cyxcbiAgICBvdmVySW5kZXhcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGFjdGl2ZU5vZGVSZWN0ID0gKF9yZWN0cyRhY3RpdmVJbmRleCA9IHJlY3RzW2FjdGl2ZUluZGV4XSkgIT0gbnVsbCA/IF9yZWN0cyRhY3RpdmVJbmRleCA6IGZhbGxiYWNrQWN0aXZlUmVjdDtcblxuICBpZiAoIWFjdGl2ZU5vZGVSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoaW5kZXggPT09IGFjdGl2ZUluZGV4KSB7XG4gICAgY29uc3Qgb3ZlckluZGV4UmVjdCA9IHJlY3RzW292ZXJJbmRleF07XG5cbiAgICBpZiAoIW92ZXJJbmRleFJlY3QpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogYWN0aXZlSW5kZXggPCBvdmVySW5kZXggPyBvdmVySW5kZXhSZWN0LnRvcCArIG92ZXJJbmRleFJlY3QuaGVpZ2h0IC0gKGFjdGl2ZU5vZGVSZWN0LnRvcCArIGFjdGl2ZU5vZGVSZWN0LmhlaWdodCkgOiBvdmVySW5kZXhSZWN0LnRvcCAtIGFjdGl2ZU5vZGVSZWN0LnRvcCxcbiAgICAgIC4uLmRlZmF1bHRTY2FsZSQxXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGl0ZW1HYXAgPSBnZXRJdGVtR2FwJDEocmVjdHMsIGluZGV4LCBhY3RpdmVJbmRleCk7XG5cbiAgaWYgKGluZGV4ID4gYWN0aXZlSW5kZXggJiYgaW5kZXggPD0gb3ZlckluZGV4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAtYWN0aXZlTm9kZVJlY3QuaGVpZ2h0IC0gaXRlbUdhcCxcbiAgICAgIC4uLmRlZmF1bHRTY2FsZSQxXG4gICAgfTtcbiAgfVxuXG4gIGlmIChpbmRleCA8IGFjdGl2ZUluZGV4ICYmIGluZGV4ID49IG92ZXJJbmRleCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogYWN0aXZlTm9kZVJlY3QuaGVpZ2h0ICsgaXRlbUdhcCxcbiAgICAgIC4uLmRlZmF1bHRTY2FsZSQxXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIC4uLmRlZmF1bHRTY2FsZSQxXG4gIH07XG59O1xuXG5mdW5jdGlvbiBnZXRJdGVtR2FwJDEoY2xpZW50UmVjdHMsIGluZGV4LCBhY3RpdmVJbmRleCkge1xuICBjb25zdCBjdXJyZW50UmVjdCA9IGNsaWVudFJlY3RzW2luZGV4XTtcbiAgY29uc3QgcHJldmlvdXNSZWN0ID0gY2xpZW50UmVjdHNbaW5kZXggLSAxXTtcbiAgY29uc3QgbmV4dFJlY3QgPSBjbGllbnRSZWN0c1tpbmRleCArIDFdO1xuXG4gIGlmICghY3VycmVudFJlY3QpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGlmIChhY3RpdmVJbmRleCA8IGluZGV4KSB7XG4gICAgcmV0dXJuIHByZXZpb3VzUmVjdCA/IGN1cnJlbnRSZWN0LnRvcCAtIChwcmV2aW91c1JlY3QudG9wICsgcHJldmlvdXNSZWN0LmhlaWdodCkgOiBuZXh0UmVjdCA/IG5leHRSZWN0LnRvcCAtIChjdXJyZW50UmVjdC50b3AgKyBjdXJyZW50UmVjdC5oZWlnaHQpIDogMDtcbiAgfVxuXG4gIHJldHVybiBuZXh0UmVjdCA/IG5leHRSZWN0LnRvcCAtIChjdXJyZW50UmVjdC50b3AgKyBjdXJyZW50UmVjdC5oZWlnaHQpIDogcHJldmlvdXNSZWN0ID8gY3VycmVudFJlY3QudG9wIC0gKHByZXZpb3VzUmVjdC50b3AgKyBwcmV2aW91c1JlY3QuaGVpZ2h0KSA6IDA7XG59XG5cbmNvbnN0IElEX1BSRUZJWCA9ICdTb3J0YWJsZSc7XG5jb25zdCBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBhY3RpdmVJbmRleDogLTEsXG4gIGNvbnRhaW5lcklkOiBJRF9QUkVGSVgsXG4gIGRpc2FibGVUcmFuc2Zvcm1zOiBmYWxzZSxcbiAgaXRlbXM6IFtdLFxuICBvdmVySW5kZXg6IC0xLFxuICB1c2VEcmFnT3ZlcmxheTogZmFsc2UsXG4gIHNvcnRlZFJlY3RzOiBbXSxcbiAgc3RyYXRlZ3k6IHJlY3RTb3J0aW5nU3RyYXRlZ3ksXG4gIGRpc2FibGVkOiB7XG4gICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICBkcm9wcGFibGU6IGZhbHNlXG4gIH1cbn0pO1xuZnVuY3Rpb24gU29ydGFibGVDb250ZXh0KF9yZWYpIHtcbiAgbGV0IHtcbiAgICBjaGlsZHJlbixcbiAgICBpZCxcbiAgICBpdGVtczogdXNlckRlZmluZWRJdGVtcyxcbiAgICBzdHJhdGVneSA9IHJlY3RTb3J0aW5nU3RyYXRlZ3ksXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkUHJvcCA9IGZhbHNlXG4gIH0gPSBfcmVmO1xuICBjb25zdCB7XG4gICAgYWN0aXZlLFxuICAgIGRyYWdPdmVybGF5LFxuICAgIGRyb3BwYWJsZVJlY3RzLFxuICAgIG92ZXIsXG4gICAgbWVhc3VyZURyb3BwYWJsZUNvbnRhaW5lcnNcbiAgfSA9IHVzZURuZENvbnRleHQoKTtcbiAgY29uc3QgY29udGFpbmVySWQgPSB1c2VVbmlxdWVJZChJRF9QUkVGSVgsIGlkKTtcbiAgY29uc3QgdXNlRHJhZ092ZXJsYXkgPSBCb29sZWFuKGRyYWdPdmVybGF5LnJlY3QgIT09IG51bGwpO1xuICBjb25zdCBpdGVtcyA9IHVzZU1lbW8oKCkgPT4gdXNlckRlZmluZWRJdGVtcy5tYXAoaXRlbSA9PiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcgJiYgJ2lkJyBpbiBpdGVtID8gaXRlbS5pZCA6IGl0ZW0pLCBbdXNlckRlZmluZWRJdGVtc10pO1xuICBjb25zdCBpc0RyYWdnaW5nID0gYWN0aXZlICE9IG51bGw7XG4gIGNvbnN0IGFjdGl2ZUluZGV4ID0gYWN0aXZlID8gaXRlbXMuaW5kZXhPZihhY3RpdmUuaWQpIDogLTE7XG4gIGNvbnN0IG92ZXJJbmRleCA9IG92ZXIgPyBpdGVtcy5pbmRleE9mKG92ZXIuaWQpIDogLTE7XG4gIGNvbnN0IHByZXZpb3VzSXRlbXNSZWYgPSB1c2VSZWYoaXRlbXMpO1xuICBjb25zdCBpdGVtc0hhdmVDaGFuZ2VkID0gIWl0ZW1zRXF1YWwoaXRlbXMsIHByZXZpb3VzSXRlbXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGRpc2FibGVUcmFuc2Zvcm1zID0gb3ZlckluZGV4ICE9PSAtMSAmJiBhY3RpdmVJbmRleCA9PT0gLTEgfHwgaXRlbXNIYXZlQ2hhbmdlZDtcbiAgY29uc3QgZGlzYWJsZWQgPSBub3JtYWxpemVEaXNhYmxlZChkaXNhYmxlZFByb3ApO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXRlbXNIYXZlQ2hhbmdlZCAmJiBpc0RyYWdnaW5nKSB7XG4gICAgICBtZWFzdXJlRHJvcHBhYmxlQ29udGFpbmVycyhpdGVtcyk7XG4gICAgfVxuICB9LCBbaXRlbXNIYXZlQ2hhbmdlZCwgaXRlbXMsIGlzRHJhZ2dpbmcsIG1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcHJldmlvdXNJdGVtc1JlZi5jdXJyZW50ID0gaXRlbXM7XG4gIH0sIFtpdGVtc10pO1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgY29udGFpbmVySWQsXG4gICAgZGlzYWJsZWQsXG4gICAgZGlzYWJsZVRyYW5zZm9ybXMsXG4gICAgaXRlbXMsXG4gICAgb3ZlckluZGV4LFxuICAgIHVzZURyYWdPdmVybGF5LFxuICAgIHNvcnRlZFJlY3RzOiBnZXRTb3J0ZWRSZWN0cyhpdGVtcywgZHJvcHBhYmxlUmVjdHMpLFxuICAgIHN0cmF0ZWd5XG4gIH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFthY3RpdmVJbmRleCwgY29udGFpbmVySWQsIGRpc2FibGVkLmRyYWdnYWJsZSwgZGlzYWJsZWQuZHJvcHBhYmxlLCBkaXNhYmxlVHJhbnNmb3JtcywgaXRlbXMsIG92ZXJJbmRleCwgZHJvcHBhYmxlUmVjdHMsIHVzZURyYWdPdmVybGF5LCBzdHJhdGVneV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmNvbnN0IGRlZmF1bHROZXdJbmRleEdldHRlciA9IF9yZWYgPT4ge1xuICBsZXQge1xuICAgIGlkLFxuICAgIGl0ZW1zLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG92ZXJJbmRleFxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIGFycmF5TW92ZShpdGVtcywgYWN0aXZlSW5kZXgsIG92ZXJJbmRleCkuaW5kZXhPZihpZCk7XG59O1xuY29uc3QgZGVmYXVsdEFuaW1hdGVMYXlvdXRDaGFuZ2VzID0gX3JlZjIgPT4ge1xuICBsZXQge1xuICAgIGNvbnRhaW5lcklkLFxuICAgIGlzU29ydGluZyxcbiAgICB3YXNEcmFnZ2luZyxcbiAgICBpbmRleCxcbiAgICBpdGVtcyxcbiAgICBuZXdJbmRleCxcbiAgICBwcmV2aW91c0l0ZW1zLFxuICAgIHByZXZpb3VzQ29udGFpbmVySWQsXG4gICAgdHJhbnNpdGlvblxuICB9ID0gX3JlZjI7XG5cbiAgaWYgKCF0cmFuc2l0aW9uIHx8ICF3YXNEcmFnZ2luZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChwcmV2aW91c0l0ZW1zICE9PSBpdGVtcyAmJiBpbmRleCA9PT0gbmV3SW5kZXgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNTb3J0aW5nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gbmV3SW5kZXggIT09IGluZGV4ICYmIGNvbnRhaW5lcklkID09PSBwcmV2aW91c0NvbnRhaW5lcklkO1xufTtcbmNvbnN0IGRlZmF1bHRUcmFuc2l0aW9uID0ge1xuICBkdXJhdGlvbjogMjAwLFxuICBlYXNpbmc6ICdlYXNlJ1xufTtcbmNvbnN0IHRyYW5zaXRpb25Qcm9wZXJ0eSA9ICd0cmFuc2Zvcm0nO1xuY29uc3QgZGlzYWJsZWRUcmFuc2l0aW9uID0gLyojX19QVVJFX18qL0NTUy5UcmFuc2l0aW9uLnRvU3RyaW5nKHtcbiAgcHJvcGVydHk6IHRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgZHVyYXRpb246IDAsXG4gIGVhc2luZzogJ2xpbmVhcidcbn0pO1xuY29uc3QgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7XG4gIHJvbGVEZXNjcmlwdGlvbjogJ3NvcnRhYmxlJ1xufTtcblxuLypcclxuICogV2hlbiB0aGUgaW5kZXggb2YgYW4gaXRlbSBjaGFuZ2VzIHdoaWxlIHNvcnRpbmcsXHJcbiAqIHdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgZGlzYWJsZSB0aGUgdHJhbnNmb3Jtc1xyXG4gKi9cblxuZnVuY3Rpb24gdXNlRGVyaXZlZFRyYW5zZm9ybShfcmVmKSB7XG4gIGxldCB7XG4gICAgZGlzYWJsZWQsXG4gICAgaW5kZXgsXG4gICAgbm9kZSxcbiAgICByZWN0XG4gIH0gPSBfcmVmO1xuICBjb25zdCBbZGVyaXZlZFRyYW5zZm9ybSwgc2V0RGVyaXZlZHRyYW5zZm9ybV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcHJldmlvdXNJbmRleCA9IHVzZVJlZihpbmRleCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZGlzYWJsZWQgJiYgaW5kZXggIT09IHByZXZpb3VzSW5kZXguY3VycmVudCAmJiBub2RlLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGluaXRpYWwgPSByZWN0LmN1cnJlbnQ7XG5cbiAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBnZXRDbGllbnRSZWN0KG5vZGUuY3VycmVudCwge1xuICAgICAgICAgIGlnbm9yZVRyYW5zZm9ybTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZGVsdGEgPSB7XG4gICAgICAgICAgeDogaW5pdGlhbC5sZWZ0IC0gY3VycmVudC5sZWZ0LFxuICAgICAgICAgIHk6IGluaXRpYWwudG9wIC0gY3VycmVudC50b3AsXG4gICAgICAgICAgc2NhbGVYOiBpbml0aWFsLndpZHRoIC8gY3VycmVudC53aWR0aCxcbiAgICAgICAgICBzY2FsZVk6IGluaXRpYWwuaGVpZ2h0IC8gY3VycmVudC5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZGVsdGEueCB8fCBkZWx0YS55KSB7XG4gICAgICAgICAgc2V0RGVyaXZlZHRyYW5zZm9ybShkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT09IHByZXZpb3VzSW5kZXguY3VycmVudCkge1xuICAgICAgcHJldmlvdXNJbmRleC5jdXJyZW50ID0gaW5kZXg7XG4gICAgfVxuICB9LCBbZGlzYWJsZWQsIGluZGV4LCBub2RlLCByZWN0XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGRlcml2ZWRUcmFuc2Zvcm0pIHtcbiAgICAgIHNldERlcml2ZWR0cmFuc2Zvcm0obnVsbCk7XG4gICAgfVxuICB9LCBbZGVyaXZlZFRyYW5zZm9ybV0pO1xuICByZXR1cm4gZGVyaXZlZFRyYW5zZm9ybTtcbn1cblxuZnVuY3Rpb24gdXNlU29ydGFibGUoX3JlZikge1xuICBsZXQge1xuICAgIGFuaW1hdGVMYXlvdXRDaGFuZ2VzID0gZGVmYXVsdEFuaW1hdGVMYXlvdXRDaGFuZ2VzLFxuICAgIGF0dHJpYnV0ZXM6IHVzZXJEZWZpbmVkQXR0cmlidXRlcyxcbiAgICBkaXNhYmxlZDogbG9jYWxEaXNhYmxlZCxcbiAgICBkYXRhOiBjdXN0b21EYXRhLFxuICAgIGdldE5ld0luZGV4ID0gZGVmYXVsdE5ld0luZGV4R2V0dGVyLFxuICAgIGlkLFxuICAgIHN0cmF0ZWd5OiBsb2NhbFN0cmF0ZWd5LFxuICAgIHJlc2l6ZU9ic2VydmVyQ29uZmlnLFxuICAgIHRyYW5zaXRpb24gPSBkZWZhdWx0VHJhbnNpdGlvblxuICB9ID0gX3JlZjtcbiAgY29uc3Qge1xuICAgIGl0ZW1zLFxuICAgIGNvbnRhaW5lcklkLFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIGRpc2FibGVkOiBnbG9iYWxEaXNhYmxlZCxcbiAgICBkaXNhYmxlVHJhbnNmb3JtcyxcbiAgICBzb3J0ZWRSZWN0cyxcbiAgICBvdmVySW5kZXgsXG4gICAgdXNlRHJhZ092ZXJsYXksXG4gICAgc3RyYXRlZ3k6IGdsb2JhbFN0cmF0ZWd5XG4gIH0gPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICBjb25zdCBkaXNhYmxlZCA9IG5vcm1hbGl6ZUxvY2FsRGlzYWJsZWQobG9jYWxEaXNhYmxlZCwgZ2xvYmFsRGlzYWJsZWQpO1xuICBjb25zdCBpbmRleCA9IGl0ZW1zLmluZGV4T2YoaWQpO1xuICBjb25zdCBkYXRhID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHNvcnRhYmxlOiB7XG4gICAgICBjb250YWluZXJJZCxcbiAgICAgIGluZGV4LFxuICAgICAgaXRlbXNcbiAgICB9LFxuICAgIC4uLmN1c3RvbURhdGFcbiAgfSksIFtjb250YWluZXJJZCwgY3VzdG9tRGF0YSwgaW5kZXgsIGl0ZW1zXSk7XG4gIGNvbnN0IGl0ZW1zQWZ0ZXJDdXJyZW50U29ydGFibGUgPSB1c2VNZW1vKCgpID0+IGl0ZW1zLnNsaWNlKGl0ZW1zLmluZGV4T2YoaWQpKSwgW2l0ZW1zLCBpZF0pO1xuICBjb25zdCB7XG4gICAgcmVjdCxcbiAgICBub2RlLFxuICAgIGlzT3ZlcixcbiAgICBzZXROb2RlUmVmOiBzZXREcm9wcGFibGVOb2RlUmVmXG4gIH0gPSB1c2VEcm9wcGFibGUoe1xuICAgIGlkLFxuICAgIGRhdGEsXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLmRyb3BwYWJsZSxcbiAgICByZXNpemVPYnNlcnZlckNvbmZpZzoge1xuICAgICAgdXBkYXRlTWVhc3VyZW1lbnRzRm9yOiBpdGVtc0FmdGVyQ3VycmVudFNvcnRhYmxlLFxuICAgICAgLi4ucmVzaXplT2JzZXJ2ZXJDb25maWdcbiAgICB9XG4gIH0pO1xuICBjb25zdCB7XG4gICAgYWN0aXZlLFxuICAgIGFjdGl2YXRvckV2ZW50LFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgc2V0Tm9kZVJlZjogc2V0RHJhZ2dhYmxlTm9kZVJlZixcbiAgICBsaXN0ZW5lcnMsXG4gICAgaXNEcmFnZ2luZyxcbiAgICBvdmVyLFxuICAgIHNldEFjdGl2YXRvck5vZGVSZWYsXG4gICAgdHJhbnNmb3JtXG4gIH0gPSB1c2VEcmFnZ2FibGUoe1xuICAgIGlkLFxuICAgIGRhdGEsXG4gICAgYXR0cmlidXRlczogeyAuLi5kZWZhdWx0QXR0cmlidXRlcyxcbiAgICAgIC4uLnVzZXJEZWZpbmVkQXR0cmlidXRlc1xuICAgIH0sXG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLmRyYWdnYWJsZVxuICB9KTtcbiAgY29uc3Qgc2V0Tm9kZVJlZiA9IHVzZUNvbWJpbmVkUmVmcyhzZXREcm9wcGFibGVOb2RlUmVmLCBzZXREcmFnZ2FibGVOb2RlUmVmKTtcbiAgY29uc3QgaXNTb3J0aW5nID0gQm9vbGVhbihhY3RpdmUpO1xuICBjb25zdCBkaXNwbGFjZUl0ZW0gPSBpc1NvcnRpbmcgJiYgIWRpc2FibGVUcmFuc2Zvcm1zICYmIGlzVmFsaWRJbmRleChhY3RpdmVJbmRleCkgJiYgaXNWYWxpZEluZGV4KG92ZXJJbmRleCk7XG4gIGNvbnN0IHNob3VsZERpc3BsYWNlRHJhZ1NvdXJjZSA9ICF1c2VEcmFnT3ZlcmxheSAmJiBpc0RyYWdnaW5nO1xuICBjb25zdCBkcmFnU291cmNlRGlzcGxhY2VtZW50ID0gc2hvdWxkRGlzcGxhY2VEcmFnU291cmNlICYmIGRpc3BsYWNlSXRlbSA/IHRyYW5zZm9ybSA6IG51bGw7XG4gIGNvbnN0IHN0cmF0ZWd5ID0gbG9jYWxTdHJhdGVneSAhPSBudWxsID8gbG9jYWxTdHJhdGVneSA6IGdsb2JhbFN0cmF0ZWd5O1xuICBjb25zdCBmaW5hbFRyYW5zZm9ybSA9IGRpc3BsYWNlSXRlbSA/IGRyYWdTb3VyY2VEaXNwbGFjZW1lbnQgIT0gbnVsbCA/IGRyYWdTb3VyY2VEaXNwbGFjZW1lbnQgOiBzdHJhdGVneSh7XG4gICAgcmVjdHM6IHNvcnRlZFJlY3RzLFxuICAgIGFjdGl2ZU5vZGVSZWN0LFxuICAgIGFjdGl2ZUluZGV4LFxuICAgIG92ZXJJbmRleCxcbiAgICBpbmRleFxuICB9KSA6IG51bGw7XG4gIGNvbnN0IG5ld0luZGV4ID0gaXNWYWxpZEluZGV4KGFjdGl2ZUluZGV4KSAmJiBpc1ZhbGlkSW5kZXgob3ZlckluZGV4KSA/IGdldE5ld0luZGV4KHtcbiAgICBpZCxcbiAgICBpdGVtcyxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvdmVySW5kZXhcbiAgfSkgOiBpbmRleDtcbiAgY29uc3QgYWN0aXZlSWQgPSBhY3RpdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGFjdGl2ZS5pZDtcbiAgY29uc3QgcHJldmlvdXMgPSB1c2VSZWYoe1xuICAgIGFjdGl2ZUlkLFxuICAgIGl0ZW1zLFxuICAgIG5ld0luZGV4LFxuICAgIGNvbnRhaW5lcklkXG4gIH0pO1xuICBjb25zdCBpdGVtc0hhdmVDaGFuZ2VkID0gaXRlbXMgIT09IHByZXZpb3VzLmN1cnJlbnQuaXRlbXM7XG4gIGNvbnN0IHNob3VsZEFuaW1hdGVMYXlvdXRDaGFuZ2VzID0gYW5pbWF0ZUxheW91dENoYW5nZXMoe1xuICAgIGFjdGl2ZSxcbiAgICBjb250YWluZXJJZCxcbiAgICBpc0RyYWdnaW5nLFxuICAgIGlzU29ydGluZyxcbiAgICBpZCxcbiAgICBpbmRleCxcbiAgICBpdGVtcyxcbiAgICBuZXdJbmRleDogcHJldmlvdXMuY3VycmVudC5uZXdJbmRleCxcbiAgICBwcmV2aW91c0l0ZW1zOiBwcmV2aW91cy5jdXJyZW50Lml0ZW1zLFxuICAgIHByZXZpb3VzQ29udGFpbmVySWQ6IHByZXZpb3VzLmN1cnJlbnQuY29udGFpbmVySWQsXG4gICAgdHJhbnNpdGlvbixcbiAgICB3YXNEcmFnZ2luZzogcHJldmlvdXMuY3VycmVudC5hY3RpdmVJZCAhPSBudWxsXG4gIH0pO1xuICBjb25zdCBkZXJpdmVkVHJhbnNmb3JtID0gdXNlRGVyaXZlZFRyYW5zZm9ybSh7XG4gICAgZGlzYWJsZWQ6ICFzaG91bGRBbmltYXRlTGF5b3V0Q2hhbmdlcyxcbiAgICBpbmRleCxcbiAgICBub2RlLFxuICAgIHJlY3RcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzU29ydGluZyAmJiBwcmV2aW91cy5jdXJyZW50Lm5ld0luZGV4ICE9PSBuZXdJbmRleCkge1xuICAgICAgcHJldmlvdXMuY3VycmVudC5uZXdJbmRleCA9IG5ld0luZGV4O1xuICAgIH1cblxuICAgIGlmIChjb250YWluZXJJZCAhPT0gcHJldmlvdXMuY3VycmVudC5jb250YWluZXJJZCkge1xuICAgICAgcHJldmlvdXMuY3VycmVudC5jb250YWluZXJJZCA9IGNvbnRhaW5lcklkO1xuICAgIH1cblxuICAgIGlmIChpdGVtcyAhPT0gcHJldmlvdXMuY3VycmVudC5pdGVtcykge1xuICAgICAgcHJldmlvdXMuY3VycmVudC5pdGVtcyA9IGl0ZW1zO1xuICAgIH1cbiAgfSwgW2lzU29ydGluZywgbmV3SW5kZXgsIGNvbnRhaW5lcklkLCBpdGVtc10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3RpdmVJZCA9PT0gcHJldmlvdXMuY3VycmVudC5hY3RpdmVJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmVJZCAmJiAhcHJldmlvdXMuY3VycmVudC5hY3RpdmVJZCkge1xuICAgICAgcHJldmlvdXMuY3VycmVudC5hY3RpdmVJZCA9IGFjdGl2ZUlkO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcHJldmlvdXMuY3VycmVudC5hY3RpdmVJZCA9IGFjdGl2ZUlkO1xuICAgIH0sIDUwKTtcbiAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gIH0sIFthY3RpdmVJZF0pO1xuICByZXR1cm4ge1xuICAgIGFjdGl2ZSxcbiAgICBhY3RpdmVJbmRleCxcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGRhdGEsXG4gICAgcmVjdCxcbiAgICBpbmRleCxcbiAgICBuZXdJbmRleCxcbiAgICBpdGVtcyxcbiAgICBpc092ZXIsXG4gICAgaXNTb3J0aW5nLFxuICAgIGlzRHJhZ2dpbmcsXG4gICAgbGlzdGVuZXJzLFxuICAgIG5vZGUsXG4gICAgb3ZlckluZGV4LFxuICAgIG92ZXIsXG4gICAgc2V0Tm9kZVJlZixcbiAgICBzZXRBY3RpdmF0b3JOb2RlUmVmLFxuICAgIHNldERyb3BwYWJsZU5vZGVSZWYsXG4gICAgc2V0RHJhZ2dhYmxlTm9kZVJlZixcbiAgICB0cmFuc2Zvcm06IGRlcml2ZWRUcmFuc2Zvcm0gIT0gbnVsbCA/IGRlcml2ZWRUcmFuc2Zvcm0gOiBmaW5hbFRyYW5zZm9ybSxcbiAgICB0cmFuc2l0aW9uOiBnZXRUcmFuc2l0aW9uKClcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uKCkge1xuICAgIGlmICggLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSB0cmFuc2l0aW9ucyBmb3IgYSBzaW5nbGUgZnJhbWUgdG8gc2V0IHVwIGRlcml2ZWQgdHJhbnNmb3Jtc1xuICAgIGRlcml2ZWRUcmFuc2Zvcm0gfHwgLy8gT3IgdG8gcHJldmVudCBpdGVtcyBqdW1waW5nIHRvIGJhY2sgdG8gdGhlaXIgXCJuZXdcIiBwb3NpdGlvbiB3aGVuIGl0ZW1zIGNoYW5nZVxuICAgIGl0ZW1zSGF2ZUNoYW5nZWQgJiYgcHJldmlvdXMuY3VycmVudC5uZXdJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlZFRyYW5zaXRpb247XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZERpc3BsYWNlRHJhZ1NvdXJjZSAmJiAhaXNLZXlib2FyZEV2ZW50KGFjdGl2YXRvckV2ZW50KSB8fCAhdHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoaXNTb3J0aW5nIHx8IHNob3VsZEFuaW1hdGVMYXlvdXRDaGFuZ2VzKSB7XG4gICAgICByZXR1cm4gQ1NTLlRyYW5zaXRpb24udG9TdHJpbmcoeyAuLi50cmFuc2l0aW9uLFxuICAgICAgICBwcm9wZXJ0eTogdHJhbnNpdGlvblByb3BlcnR5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxvY2FsRGlzYWJsZWQobG9jYWxEaXNhYmxlZCwgZ2xvYmFsRGlzYWJsZWQpIHtcbiAgdmFyIF9sb2NhbERpc2FibGVkJGRyYWdnYSwgX2xvY2FsRGlzYWJsZWQkZHJvcHBhO1xuXG4gIGlmICh0eXBlb2YgbG9jYWxEaXNhYmxlZCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRyYWdnYWJsZTogbG9jYWxEaXNhYmxlZCxcbiAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICBkcm9wcGFibGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZHJhZ2dhYmxlOiAoX2xvY2FsRGlzYWJsZWQkZHJhZ2dhID0gbG9jYWxEaXNhYmxlZCA9PSBudWxsID8gdm9pZCAwIDogbG9jYWxEaXNhYmxlZC5kcmFnZ2FibGUpICE9IG51bGwgPyBfbG9jYWxEaXNhYmxlZCRkcmFnZ2EgOiBnbG9iYWxEaXNhYmxlZC5kcmFnZ2FibGUsXG4gICAgZHJvcHBhYmxlOiAoX2xvY2FsRGlzYWJsZWQkZHJvcHBhID0gbG9jYWxEaXNhYmxlZCA9PSBudWxsID8gdm9pZCAwIDogbG9jYWxEaXNhYmxlZC5kcm9wcGFibGUpICE9IG51bGwgPyBfbG9jYWxEaXNhYmxlZCRkcm9wcGEgOiBnbG9iYWxEaXNhYmxlZC5kcm9wcGFibGVcbiAgfTtcbn1cblxuZnVuY3Rpb24gaGFzU29ydGFibGVEYXRhKGVudHJ5KSB7XG4gIGlmICghZW50cnkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBkYXRhID0gZW50cnkuZGF0YS5jdXJyZW50O1xuXG4gIGlmIChkYXRhICYmICdzb3J0YWJsZScgaW4gZGF0YSAmJiB0eXBlb2YgZGF0YS5zb3J0YWJsZSA9PT0gJ29iamVjdCcgJiYgJ2NvbnRhaW5lcklkJyBpbiBkYXRhLnNvcnRhYmxlICYmICdpdGVtcycgaW4gZGF0YS5zb3J0YWJsZSAmJiAnaW5kZXgnIGluIGRhdGEuc29ydGFibGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgZGlyZWN0aW9ucyA9IFtLZXlib2FyZENvZGUuRG93biwgS2V5Ym9hcmRDb2RlLlJpZ2h0LCBLZXlib2FyZENvZGUuVXAsIEtleWJvYXJkQ29kZS5MZWZ0XTtcbmNvbnN0IHNvcnRhYmxlS2V5Ym9hcmRDb29yZGluYXRlcyA9IChldmVudCwgX3JlZikgPT4ge1xuICBsZXQge1xuICAgIGNvbnRleHQ6IHtcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGNvbGxpc2lvblJlY3QsXG4gICAgICBkcm9wcGFibGVSZWN0cyxcbiAgICAgIGRyb3BwYWJsZUNvbnRhaW5lcnMsXG4gICAgICBvdmVyLFxuICAgICAgc2Nyb2xsYWJsZUFuY2VzdG9yc1xuICAgIH1cbiAgfSA9IF9yZWY7XG5cbiAgaWYgKGRpcmVjdGlvbnMuaW5jbHVkZXMoZXZlbnQuY29kZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKCFhY3RpdmUgfHwgIWNvbGxpc2lvblJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBmaWx0ZXJlZENvbnRhaW5lcnMgPSBbXTtcbiAgICBkcm9wcGFibGVDb250YWluZXJzLmdldEVuYWJsZWQoKS5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgIGlmICghZW50cnkgfHwgZW50cnkgIT0gbnVsbCAmJiBlbnRyeS5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY3QgPSBkcm9wcGFibGVSZWN0cy5nZXQoZW50cnkuaWQpO1xuXG4gICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGV2ZW50LmNvZGUpIHtcbiAgICAgICAgY2FzZSBLZXlib2FyZENvZGUuRG93bjpcbiAgICAgICAgICBpZiAoY29sbGlzaW9uUmVjdC50b3AgPCByZWN0LnRvcCkge1xuICAgICAgICAgICAgZmlsdGVyZWRDb250YWluZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgS2V5Ym9hcmRDb2RlLlVwOlxuICAgICAgICAgIGlmIChjb2xsaXNpb25SZWN0LnRvcCA+IHJlY3QudG9wKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZENvbnRhaW5lcnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBLZXlib2FyZENvZGUuTGVmdDpcbiAgICAgICAgICBpZiAoY29sbGlzaW9uUmVjdC5sZWZ0ID4gcmVjdC5sZWZ0KSB7XG4gICAgICAgICAgICBmaWx0ZXJlZENvbnRhaW5lcnMucHVzaChlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBLZXlib2FyZENvZGUuUmlnaHQ6XG4gICAgICAgICAgaWYgKGNvbGxpc2lvblJlY3QubGVmdCA8IHJlY3QubGVmdCkge1xuICAgICAgICAgICAgZmlsdGVyZWRDb250YWluZXJzLnB1c2goZW50cnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGNvbGxpc2lvbnMgPSBjbG9zZXN0Q29ybmVycyh7XG4gICAgICBhY3RpdmUsXG4gICAgICBjb2xsaXNpb25SZWN0OiBjb2xsaXNpb25SZWN0LFxuICAgICAgZHJvcHBhYmxlUmVjdHMsXG4gICAgICBkcm9wcGFibGVDb250YWluZXJzOiBmaWx0ZXJlZENvbnRhaW5lcnMsXG4gICAgICBwb2ludGVyQ29vcmRpbmF0ZXM6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgY2xvc2VzdElkID0gZ2V0Rmlyc3RDb2xsaXNpb24oY29sbGlzaW9ucywgJ2lkJyk7XG5cbiAgICBpZiAoY2xvc2VzdElkID09PSAob3ZlciA9PSBudWxsID8gdm9pZCAwIDogb3Zlci5pZCkgJiYgY29sbGlzaW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICBjbG9zZXN0SWQgPSBjb2xsaXNpb25zWzFdLmlkO1xuICAgIH1cblxuICAgIGlmIChjbG9zZXN0SWQgIT0gbnVsbCkge1xuICAgICAgY29uc3QgYWN0aXZlRHJvcHBhYmxlID0gZHJvcHBhYmxlQ29udGFpbmVycy5nZXQoYWN0aXZlLmlkKTtcbiAgICAgIGNvbnN0IG5ld0Ryb3BwYWJsZSA9IGRyb3BwYWJsZUNvbnRhaW5lcnMuZ2V0KGNsb3Nlc3RJZCk7XG4gICAgICBjb25zdCBuZXdSZWN0ID0gbmV3RHJvcHBhYmxlID8gZHJvcHBhYmxlUmVjdHMuZ2V0KG5ld0Ryb3BwYWJsZS5pZCkgOiBudWxsO1xuICAgICAgY29uc3QgbmV3Tm9kZSA9IG5ld0Ryb3BwYWJsZSA9PSBudWxsID8gdm9pZCAwIDogbmV3RHJvcHBhYmxlLm5vZGUuY3VycmVudDtcblxuICAgICAgaWYgKG5ld05vZGUgJiYgbmV3UmVjdCAmJiBhY3RpdmVEcm9wcGFibGUgJiYgbmV3RHJvcHBhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5ld1Njcm9sbEFuY2VzdG9ycyA9IGdldFNjcm9sbGFibGVBbmNlc3RvcnMobmV3Tm9kZSk7XG4gICAgICAgIGNvbnN0IGhhc0RpZmZlcmVudFNjcm9sbEFuY2VzdG9ycyA9IG5ld1Njcm9sbEFuY2VzdG9ycy5zb21lKChlbGVtZW50LCBpbmRleCkgPT4gc2Nyb2xsYWJsZUFuY2VzdG9yc1tpbmRleF0gIT09IGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBoYXNTYW1lQ29udGFpbmVyID0gaXNTYW1lQ29udGFpbmVyKGFjdGl2ZURyb3BwYWJsZSwgbmV3RHJvcHBhYmxlKTtcbiAgICAgICAgY29uc3QgaXNBZnRlckFjdGl2ZSA9IGlzQWZ0ZXIoYWN0aXZlRHJvcHBhYmxlLCBuZXdEcm9wcGFibGUpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBoYXNEaWZmZXJlbnRTY3JvbGxBbmNlc3RvcnMgfHwgIWhhc1NhbWVDb250YWluZXIgPyB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgeDogaXNBZnRlckFjdGl2ZSA/IGNvbGxpc2lvblJlY3Qud2lkdGggLSBuZXdSZWN0LndpZHRoIDogMCxcbiAgICAgICAgICB5OiBpc0FmdGVyQWN0aXZlID8gY29sbGlzaW9uUmVjdC5oZWlnaHQgLSBuZXdSZWN0LmhlaWdodCA6IDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVjdENvb3JkaW5hdGVzID0ge1xuICAgICAgICAgIHg6IG5ld1JlY3QubGVmdCxcbiAgICAgICAgICB5OiBuZXdSZWN0LnRvcFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXdDb29yZGluYXRlcyA9IG9mZnNldC54ICYmIG9mZnNldC55ID8gcmVjdENvb3JkaW5hdGVzIDogc3VidHJhY3QocmVjdENvb3JkaW5hdGVzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3Q29vcmRpbmF0ZXM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGlzU2FtZUNvbnRhaW5lcihhLCBiKSB7XG4gIGlmICghaGFzU29ydGFibGVEYXRhKGEpIHx8ICFoYXNTb3J0YWJsZURhdGEoYikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYS5kYXRhLmN1cnJlbnQuc29ydGFibGUuY29udGFpbmVySWQgPT09IGIuZGF0YS5jdXJyZW50LnNvcnRhYmxlLmNvbnRhaW5lcklkO1xufVxuXG5mdW5jdGlvbiBpc0FmdGVyKGEsIGIpIHtcbiAgaWYgKCFoYXNTb3J0YWJsZURhdGEoYSkgfHwgIWhhc1NvcnRhYmxlRGF0YShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNTYW1lQ29udGFpbmVyKGEsIGIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGEuZGF0YS5jdXJyZW50LnNvcnRhYmxlLmluZGV4IDwgYi5kYXRhLmN1cnJlbnQuc29ydGFibGUuaW5kZXg7XG59XG5cbmV4cG9ydCB7IFNvcnRhYmxlQ29udGV4dCwgYXJyYXlNb3ZlLCBhcnJheVN3YXAsIGRlZmF1bHRBbmltYXRlTGF5b3V0Q2hhbmdlcywgZGVmYXVsdE5ld0luZGV4R2V0dGVyLCBoYXNTb3J0YWJsZURhdGEsIGhvcml6b250YWxMaXN0U29ydGluZ1N0cmF0ZWd5LCByZWN0U29ydGluZ1N0cmF0ZWd5LCByZWN0U3dhcHBpbmdTdHJhdGVneSwgc29ydGFibGVLZXlib2FyZENvb3JkaW5hdGVzLCB1c2VTb3J0YWJsZSwgdmVydGljYWxMaXN0U29ydGluZ1N0cmF0ZWd5IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3J0YWJsZS5lc20uanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VNZW1vIiwidXNlUmVmIiwidXNlRWZmZWN0IiwidXNlU3RhdGUiLCJ1c2VDb250ZXh0IiwidXNlRG5kQ29udGV4dCIsImdldENsaWVudFJlY3QiLCJ1c2VEcm9wcGFibGUiLCJ1c2VEcmFnZ2FibGUiLCJjbG9zZXN0Q29ybmVycyIsImdldEZpcnN0Q29sbGlzaW9uIiwiZ2V0U2Nyb2xsYWJsZUFuY2VzdG9ycyIsIktleWJvYXJkQ29kZSIsInVzZVVuaXF1ZUlkIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIkNTUyIsInVzZUNvbWJpbmVkUmVmcyIsImlzS2V5Ym9hcmRFdmVudCIsInN1YnRyYWN0IiwiYXJyYXlNb3ZlIiwiYXJyYXkiLCJmcm9tIiwidG8iLCJuZXdBcnJheSIsInNsaWNlIiwic3BsaWNlIiwibGVuZ3RoIiwiYXJyYXlTd2FwIiwiZ2V0U29ydGVkUmVjdHMiLCJpdGVtcyIsInJlY3RzIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpZCIsImluZGV4IiwicmVjdCIsImdldCIsIkFycmF5IiwiaXNWYWxpZEluZGV4IiwiaXRlbXNFcXVhbCIsImEiLCJiIiwiaSIsIm5vcm1hbGl6ZURpc2FibGVkIiwiZGlzYWJsZWQiLCJkcmFnZ2FibGUiLCJkcm9wcGFibGUiLCJkZWZhdWx0U2NhbGUiLCJzY2FsZVgiLCJzY2FsZVkiLCJob3Jpem9udGFsTGlzdFNvcnRpbmdTdHJhdGVneSIsIl9yZWYiLCJfcmVjdHMkYWN0aXZlSW5kZXgiLCJhY3RpdmVOb2RlUmVjdCIsImZhbGxiYWNrQWN0aXZlUmVjdCIsImFjdGl2ZUluZGV4Iiwib3ZlckluZGV4IiwiaXRlbUdhcCIsImdldEl0ZW1HYXAiLCJuZXdJbmRleFJlY3QiLCJ4IiwibGVmdCIsIndpZHRoIiwieSIsImN1cnJlbnRSZWN0IiwicHJldmlvdXNSZWN0IiwibmV4dFJlY3QiLCJyZWN0U29ydGluZ1N0cmF0ZWd5IiwibmV3UmVjdHMiLCJvbGRSZWN0IiwibmV3UmVjdCIsInRvcCIsImhlaWdodCIsInJlY3RTd2FwcGluZ1N0cmF0ZWd5IiwiZGVmYXVsdFNjYWxlJDEiLCJ2ZXJ0aWNhbExpc3RTb3J0aW5nU3RyYXRlZ3kiLCJvdmVySW5kZXhSZWN0IiwiZ2V0SXRlbUdhcCQxIiwiY2xpZW50UmVjdHMiLCJJRF9QUkVGSVgiLCJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNvbnRhaW5lcklkIiwiZGlzYWJsZVRyYW5zZm9ybXMiLCJ1c2VEcmFnT3ZlcmxheSIsInNvcnRlZFJlY3RzIiwic3RyYXRlZ3kiLCJTb3J0YWJsZUNvbnRleHQiLCJjaGlsZHJlbiIsInVzZXJEZWZpbmVkSXRlbXMiLCJkaXNhYmxlZFByb3AiLCJhY3RpdmUiLCJkcmFnT3ZlcmxheSIsImRyb3BwYWJsZVJlY3RzIiwib3ZlciIsIm1lYXN1cmVEcm9wcGFibGVDb250YWluZXJzIiwiQm9vbGVhbiIsIm1hcCIsIml0ZW0iLCJpc0RyYWdnaW5nIiwiaW5kZXhPZiIsInByZXZpb3VzSXRlbXNSZWYiLCJpdGVtc0hhdmVDaGFuZ2VkIiwiY3VycmVudCIsImNvbnRleHRWYWx1ZSIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwiZGVmYXVsdE5ld0luZGV4R2V0dGVyIiwiZGVmYXVsdEFuaW1hdGVMYXlvdXRDaGFuZ2VzIiwiX3JlZjIiLCJpc1NvcnRpbmciLCJ3YXNEcmFnZ2luZyIsIm5ld0luZGV4IiwicHJldmlvdXNJdGVtcyIsInByZXZpb3VzQ29udGFpbmVySWQiLCJ0cmFuc2l0aW9uIiwiZGVmYXVsdFRyYW5zaXRpb24iLCJkdXJhdGlvbiIsImVhc2luZyIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsImRpc2FibGVkVHJhbnNpdGlvbiIsIlRyYW5zaXRpb24iLCJ0b1N0cmluZyIsInByb3BlcnR5IiwiZGVmYXVsdEF0dHJpYnV0ZXMiLCJyb2xlRGVzY3JpcHRpb24iLCJ1c2VEZXJpdmVkVHJhbnNmb3JtIiwibm9kZSIsImRlcml2ZWRUcmFuc2Zvcm0iLCJzZXREZXJpdmVkdHJhbnNmb3JtIiwicHJldmlvdXNJbmRleCIsImluaXRpYWwiLCJpZ25vcmVUcmFuc2Zvcm0iLCJkZWx0YSIsInVzZVNvcnRhYmxlIiwiYW5pbWF0ZUxheW91dENoYW5nZXMiLCJhdHRyaWJ1dGVzIiwidXNlckRlZmluZWRBdHRyaWJ1dGVzIiwibG9jYWxEaXNhYmxlZCIsImRhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmV3SW5kZXgiLCJsb2NhbFN0cmF0ZWd5IiwicmVzaXplT2JzZXJ2ZXJDb25maWciLCJnbG9iYWxEaXNhYmxlZCIsImdsb2JhbFN0cmF0ZWd5Iiwibm9ybWFsaXplTG9jYWxEaXNhYmxlZCIsInNvcnRhYmxlIiwiaXRlbXNBZnRlckN1cnJlbnRTb3J0YWJsZSIsImlzT3ZlciIsInNldE5vZGVSZWYiLCJzZXREcm9wcGFibGVOb2RlUmVmIiwidXBkYXRlTWVhc3VyZW1lbnRzRm9yIiwiYWN0aXZhdG9yRXZlbnQiLCJzZXREcmFnZ2FibGVOb2RlUmVmIiwibGlzdGVuZXJzIiwic2V0QWN0aXZhdG9yTm9kZVJlZiIsInRyYW5zZm9ybSIsImRpc3BsYWNlSXRlbSIsInNob3VsZERpc3BsYWNlRHJhZ1NvdXJjZSIsImRyYWdTb3VyY2VEaXNwbGFjZW1lbnQiLCJmaW5hbFRyYW5zZm9ybSIsImFjdGl2ZUlkIiwicHJldmlvdXMiLCJzaG91bGRBbmltYXRlTGF5b3V0Q2hhbmdlcyIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRUcmFuc2l0aW9uIiwidW5kZWZpbmVkIiwiX2xvY2FsRGlzYWJsZWQkZHJhZ2dhIiwiX2xvY2FsRGlzYWJsZWQkZHJvcHBhIiwiaGFzU29ydGFibGVEYXRhIiwiZW50cnkiLCJkaXJlY3Rpb25zIiwiRG93biIsIlJpZ2h0IiwiVXAiLCJMZWZ0Iiwic29ydGFibGVLZXlib2FyZENvb3JkaW5hdGVzIiwiZXZlbnQiLCJjb250ZXh0IiwiY29sbGlzaW9uUmVjdCIsImRyb3BwYWJsZUNvbnRhaW5lcnMiLCJzY3JvbGxhYmxlQW5jZXN0b3JzIiwiaW5jbHVkZXMiLCJjb2RlIiwicHJldmVudERlZmF1bHQiLCJmaWx0ZXJlZENvbnRhaW5lcnMiLCJnZXRFbmFibGVkIiwiZm9yRWFjaCIsInB1c2giLCJjb2xsaXNpb25zIiwicG9pbnRlckNvb3JkaW5hdGVzIiwiY2xvc2VzdElkIiwiYWN0aXZlRHJvcHBhYmxlIiwibmV3RHJvcHBhYmxlIiwibmV3Tm9kZSIsIm5ld1Njcm9sbEFuY2VzdG9ycyIsImhhc0RpZmZlcmVudFNjcm9sbEFuY2VzdG9ycyIsInNvbWUiLCJlbGVtZW50IiwiaGFzU2FtZUNvbnRhaW5lciIsImlzU2FtZUNvbnRhaW5lciIsImlzQWZ0ZXJBY3RpdmUiLCJpc0FmdGVyIiwib2Zmc2V0IiwicmVjdENvb3JkaW5hdGVzIiwibmV3Q29vcmRpbmF0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/.pnpm/@dnd-kit+sortable@8.0.0_@dnd-kit+core@6.3.1_react-dom@18.3.1_react@18.3.1__react@18.3.1__react@18.3.1/node_modules/@dnd-kit/sortable/dist/sortable.esm.js\n");

/***/ })

};
;