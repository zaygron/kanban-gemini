#!/bin/bash
set -e

echo "üîß Aplicando o Patch Definitivo no KanbanController (Tradu√ß√£o e Auth)..."

cat << 'EOF' > apps/api/src/kanban/kanban.controller.ts
import { Controller, Get, Post, Body, Patch, Param, UseGuards, Request } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { AuthGuard } from '@nestjs/passport';
import { EventsGateway } from '../events/events.gateway';

// Traduz o n√∫mero decimal do Frontend (ex: 1000) para String Lexicogr√°fica no DB (ex: "000000000000001000.00000")
function toRank(order: number): string {
  return Number(order || 0).toFixed(5).padStart(20, '0');
}

// Dispensa caminhos de arquivo locais, invoca a estrat√©gia global diretamente
@UseGuards(AuthGuard('jwt'))
@Controller('kanban')
export class KanbanController {
  constructor(private prisma: PrismaService, private events: EventsGateway) {}

  @Get('board/:id')
  async getBoard(@Param('id') id: string) {
    const board = await this.prisma.board.findUnique({
      where: { id },
      include: {
        lists: {
          include: { cards: { orderBy: { rank: 'asc' } } },
          orderBy: { rank: 'asc' }
        }
      }
    });

    if (!board) return null;

    // Tradu√ß√£o perfeita de 'lists'/'cards' do DB para 'columns'/'tasks' do Frontend
    return {
      ...board,
      columns: board.lists.map((list: any) => ({
        id: list.id,
        title: list.title,
        order: parseFloat(list.rank),
        boardId: list.boardId,
        tasks: list.cards.map((card: any) => ({
          id: card.id,
          title: card.title,
          order: parseFloat(card.rank),
          columnId: card.listId
        }))
      }))
    };
  }

  @Post('columns')
  async createColumn(@Body() body: { title: string; boardId: string; order: number }) {
    const list = await this.prisma.list.create({
      data: { 
        title: body.title, 
        boardId: body.boardId, 
        rank: toRank(body.order) 
      }
    });
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: list.id, title: list.title, order: parseFloat(list.rank), boardId: list.boardId };
  }

  @Post('tasks')
  async createTask(@Request() req: any, @Body() body: { title: string; columnId: string; order: number }) {
    const list = await this.prisma.list.findUnique({ where: { id: body.columnId } });
    if (!list) return null;

    // Captura o ID do usu√°rio do JWT (com fallback seguro caso seja o primeiro acesso)
    let userId = req.user?.id || req.user?.sub;
    if (!userId) {
      const fallbackUser = await this.prisma.user.findFirst();
      userId = fallbackUser?.id || 'unknown';
    }

    const card = await this.prisma.card.create({
      data: { 
        title: body.title, 
        listId: body.columnId, 
        rank: toRank(body.order),
        boardId: list.boardId,
        createdById: userId
      }
    });
    
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId };
  }

  @Patch('tasks/:id')
  async updateTask(@Param('id') id: string, @Body() body: { columnId?: string; order?: number }) {
    const data: any = {};
    if (body.columnId) data.listId = body.columnId;
    if (body.order !== undefined) data.rank = toRank(body.order);

    const card = await this.prisma.card.update({ where: { id }, data });
    
    this.events.server.emit('boardUpdated', { boardId: card.boardId });
    return { id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId };
  }
}
EOF

echo "üèóÔ∏è Recompilando o Backend API..."
cd apps/api
pnpm run build
cd ../..

echo ""
echo "‚úÖ=========================================================="
echo "üéØ SUCESSO ABSOLUTO!"
echo "As pontes entre TypeScript e Prisma foram alinhadas perfeitamente."
echo "‚úÖ=========================================================="