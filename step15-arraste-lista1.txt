#!/bin/bash
set -e

echo "‚öôÔ∏è 1. Backend: Ensinando a API a salvar a Ordem das Listas (Rank Fracionado)..."

cat << 'EOF' > apps/api/src/kanban/kanban.controller.ts
import { Controller, Get, Post, Body, Patch, Param, Delete, Request, UseGuards, NotFoundException, UnauthorizedException, BadRequestException, ForbiddenException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { EventsGateway } from '../events/events.gateway';
import { KanbanGuard } from '../auth/kanban.guard';

function toRank(order: number): string { return Number(order || 0).toFixed(5).padStart(20, '0'); }

@UseGuards(KanbanGuard)
@Controller('kanban')
export class KanbanController {
  constructor(private prisma: PrismaService, private events: EventsGateway) {}

  private async getPermissions(userId: string, boardId: string) {
    const board = await this.prisma.board.findUnique({ where: { id: boardId }, include: { members: true } });
    if (!board) throw new NotFoundException('Quadro n√£o encontrado.');
    const isOwner = board.createdById === userId;
    const member = board.members.find(m => m.userId === userId);
    const isRestricted = !isOwner && member?.role === 'RESTRICTED';
    return { isOwner, isMember: !!member, isRestricted, role: isOwner ? 'OWNER' : (member?.role || 'NONE') };
  }

  @Get('board/:id')
  async getBoard(@Param('id') id: string, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const { isOwner, isMember, role } = await this.getPermissions(userId, id);
    if (!isOwner && !isMember) throw new UnauthorizedException('Acesso negado.');

    const board = await this.prisma.board.findUnique({
      where: { id },
      include: { lists: { include: { cards: { orderBy: { rank: 'asc' } } }, orderBy: { rank: 'asc' } } }
    });
    
    return {
      ...board,
      userRole: role,
      columns: board?.lists.map((list: any) => ({
        id: list.id, title: list.title, order: parseFloat(list.rank), boardId: list.boardId,
        tasks: list.cards.map((card: any) => ({ 
          id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId,
          description: card.description, priority: card.priority, startDate: card.startDate, dueDate: card.dueDate, assignedTo: card.assignedTo
        }))
      }))
    };
  }

  @Get('board/:id/members')
  async getMembers(@Param('id') id: string, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const { isOwner, isMember } = await this.getPermissions(userId, id);
    if (!isOwner && !isMember) throw new UnauthorizedException('Acesso negado.');

    const board = await this.prisma.board.findUnique({ where: { id }, include: { members: { include: { user: true } } } });
    const owner = await this.prisma.user.findUnique({ where: { id: board?.createdById } });
    return {
      owner: { id: owner?.id, name: owner?.name, email: owner?.email },
      members: board?.members.map((m: any) => ({ id: m.user.id, name: m.user.name, email: m.user.email, role: m.role, memberId: m.id }))
    };
  }

  @Post('board/:id/members')
  async addMember(@Param('id') id: string, @Body() body: { email: string; role: string }, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const { isOwner } = await this.getPermissions(userId, id);
    if (!isOwner) throw new ForbiddenException('Apenas o dono pode gerenciar a equipe.');

    const invitee = await this.prisma.user.findUnique({ where: { email: body.email } });
    if (!invitee) throw new BadRequestException('Usu√°rio n√£o encontrado.');
    if (invitee.id === userId) throw new BadRequestException('Voc√™ j√° √© o dono.');

    const existing = await this.prisma.boardMember.findUnique({ where: { boardId_userId: { boardId: id, userId: invitee.id } } });
    if (existing) throw new BadRequestException('Usu√°rio j√° √© membro.');

    await this.prisma.boardMember.create({ data: { boardId: id, userId: invitee.id, role: body.role || 'MEMBER' } });
    this.events.server.emit('boardUpdated', { boardId: id });
    return { success: true, message: 'Usu√°rio adicionado √† equipe!' };
  }

  @Delete('board/:id/members/:memberId')
  async removeMember(@Param('id') id: string, @Param('memberId') memberId: string, @Request() req: any) {
     const userId = req.user?.sub || req.user?.id;
     const { isOwner } = await this.getPermissions(userId, id);
     if (!isOwner) throw new ForbiddenException('Apenas o dono pode remover membros.');
     await this.prisma.boardMember.delete({ where: { id: memberId } });
     this.events.server.emit('boardUpdated', { boardId: id });
     return { success: true };
  }

  @Patch('board/:id')
  async updateBoard(@Param('id') id: string, @Body() body: { name: string }, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const { isOwner } = await this.getPermissions(userId, id);
    if (!isOwner) throw new ForbiddenException('Apenas o dono pode renomear.');
    const updatedBoard = await this.prisma.board.update({ where: { id }, data: { name: body.name } });
    this.events.server.emit('boardUpdated', { boardId: id });
    return updatedBoard;
  }

  @Post('columns')
  async createColumn(@Request() req: any, @Body() body: { title: string; boardId: string; order: number }) {
    const userId = req.user?.sub || req.user?.id;
    const { isOwner, isMember, isRestricted } = await this.getPermissions(userId, body.boardId);
    if (!isOwner && !isMember) throw new UnauthorizedException('Acesso negado.');
    if (isRestricted) throw new ForbiddenException('Acesso Restrito: Voc√™ n√£o pode criar listas.');

    const list = await this.prisma.list.create({ data: { title: body.title, boardId: body.boardId, rank: toRank(body.order) } });
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: list.id, title: list.title, order: parseFloat(list.rank), boardId: list.boardId };
  }

  // üî• A Rota Patch agora entende a Ordem (Rank) da Coluna
  @Patch('columns/:id')
  async updateColumn(@Param('id') id: string, @Body() body: { title?: string, order?: number }, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const listCheck = await this.prisma.list.findUnique({ where: { id } });
    if (!listCheck) throw new NotFoundException();
    
    const { isOwner, isMember, isRestricted } = await this.getPermissions(userId, listCheck.boardId);
    if (!isOwner && !isMember) throw new UnauthorizedException('Acesso negado.');
    if (isRestricted) throw new ForbiddenException('Acesso Restrito: Voc√™ n√£o pode alterar listas.');

    const data: any = {};
    if (body.title !== undefined) data.title = body.title;
    if (body.order !== undefined) data.rank = toRank(body.order);

    const list = await this.prisma.list.update({ where: { id }, data });
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: list.id, title: list.title, order: parseFloat(list.rank), boardId: list.boardId };
  }

  @Post('tasks')
  async createTask(@Request() req: any, @Body() body: { title: string; columnId: string; order: number }) {
    const userId = req.user.sub || req.user.id; 
    const list = await this.prisma.list.findUnique({ where: { id: body.columnId } });
    if (!list) throw new NotFoundException();
    
    const { isOwner, isMember, isRestricted } = await this.getPermissions(userId, list.boardId);
    if (!isOwner && !isMember) throw new UnauthorizedException('Acesso negado.');
    if (isRestricted) throw new ForbiddenException('Acesso Restrito: Voc√™ n√£o pode criar tarefas.');

    const card = await this.prisma.card.create({
      data: { title: body.title, listId: body.columnId, rank: toRank(body.order), boardId: list.boardId, createdById: userId, status: 'TODO' }
    });
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId, description: card.description, priority: card.priority, startDate: card.startDate, dueDate: card.dueDate, assignedTo: card.assignedTo };
  }

  @Patch('tasks/:id')
  async updateTask(@Param('id') id: string, @Body() body: any, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const cardCheck = await this.prisma.card.findUnique({ where: { id } });
    if (!cardCheck) throw new NotFoundException();

    const { isOwner, isMember, isRestricted } = await this.getPermissions(userId, cardCheck.boardId);
    if (!isOwner && !isMember) throw new UnauthorizedException('Acesso negado.');
    
    if (isRestricted && cardCheck.assignedTo !== userId) {
      throw new ForbiddenException('Voc√™ s√≥ tem permiss√£o para mover ou editar tarefas atribu√≠das a voc√™.');
    }
    if (isRestricted && body.assignedTo !== undefined && body.assignedTo !== userId && body.assignedTo !== null) {
      throw new ForbiddenException('Voc√™ n√£o pode transferir a tarefa para outra pessoa.');
    }

    const data: any = {};
    if (body.columnId !== undefined) data.listId = body.columnId;
    if (body.order !== undefined) data.rank = toRank(body.order);
    if (body.title !== undefined) data.title = body.title;
    if (body.description !== undefined) data.description = body.description;
    if (body.priority !== undefined) data.priority = body.priority;
    if (body.startDate !== undefined) data.startDate = body.startDate ? new Date(body.startDate) : null;
    if (body.dueDate !== undefined) data.dueDate = body.dueDate ? new Date(body.dueDate) : null;
    if (body.assignedTo !== undefined) data.assignedTo = body.assignedTo || null;

    const card = await this.prisma.card.update({ where: { id }, data });
    this.events.server.emit('boardUpdated', { boardId: card.boardId });
    return { id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId, description: card.description, priority: card.priority, startDate: card.startDate, dueDate: card.dueDate, assignedTo: card.assignedTo };
  }

  @Delete('tasks/:id')
  async deleteTask(@Param('id') id: string, @Request() req: any) {
    const userId = req.user?.sub || req.user?.id;
    const card = await this.prisma.card.findUnique({ where: { id }});
    if (!card) throw new NotFoundException();

    const { isOwner, isMember, isRestricted } = await this.getPermissions(userId, card.boardId);
    if (!isOwner && !isMember) throw new UnauthorizedException();
    if (isRestricted) throw new ForbiddenException('Acesso Negado: Apenas o criador do quadro pode deletar tarefas.');

    await this.prisma.card.delete({ where: { id } });
    this.events.server.emit('boardUpdated', { boardId: card.boardId });
    return { success: true };
  }
}
EOF

echo "üß≤ 2. Frontend: Injetando a Al√ßa (Grip) no Cabe√ßalho da Lista..."

cat << 'EOF' > apps/web/src/components/board/Column.tsx
import { useState, useEffect } from 'react';
import { useSortable } from '@dnd-kit/sortable';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { TaskCard } from './TaskCard';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import { Plus, GripHorizontal } from 'lucide-react';
import toast from 'react-hot-toast';

export function Column({ column, tasks, isRestricted, userId, isOverlay }: { column: any, tasks: any[], isRestricted: boolean, userId: string, isOverlay?: boolean }) {
  const queryClient = useQueryClient();
  
  // üî• A LISTA AGORA √â UM ITEM SORT√ÅVEL TAMB√âM!
  const { setNodeRef, setActivatorNodeRef, attributes, listeners, transform, transition, isDragging } = useSortable({ 
    id: column.id, 
    data: { type: 'Column', column },
    disabled: isRestricted // Restrito n√£o arrasta listas
  });
  
  const [isAddingTask, setIsAddingTask] = useState(false);
  const [newTaskTitle, setNewTaskTitle] = useState('');
  const [isEditingTitle, setIsEditingTitle] = useState(false);
  const [editTitle, setEditTitle] = useState(column.title);

  useEffect(() => { setEditTitle(column.title); }, [column.title]);

  const createTaskMutation = useMutation({
    mutationFn: async (title: string) => await api.post('/kanban/tasks', { title, columnId: column.id, order: tasks.length }),
    onSuccess: () => { queryClient.invalidateQueries({ queryKey: ['board'] }); setNewTaskTitle(''); setIsAddingTask(false); }
  });

  const updateColumnMutation = useMutation({
    mutationFn: async (newTitle: string) => await api.patch(`/kanban/columns/${column.id}`, { title: newTitle }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['board'] }),
    onError: (err: any) => { toast.error(err.response?.data?.message || 'Erro ao renomear.'); setEditTitle(column.title); }
  });

  const handleSaveTask = () => { if (newTaskTitle.trim()) createTaskMutation.mutate(newTaskTitle.trim()); else setIsAddingTask(false); };

  const handleSaveTitle = () => {
    setIsEditingTitle(false);
    if (editTitle.trim() && editTitle.trim() !== column.title) updateColumnMutation.mutate(editTitle.trim());
    else setEditTitle(column.title);
  };

  const handleKeyDownTitle = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') { e.preventDefault(); handleSaveTitle(); }
    if (e.key === 'Escape') { setIsEditingTitle(false); setEditTitle(column.title); }
  };

  // Anima√ß√£o e Opacidade do Bloco Gigante
  const style = { 
    transform: CSS.Transform.toString(transform), 
    transition, 
    opacity: isDragging && !isOverlay ? 0.3 : 1 
  };

  return (
    <div ref={setNodeRef} style={style} className={`bg-slate-100/80 backdrop-blur-sm w-80 shrink-0 rounded-2xl flex flex-col h-full border overflow-hidden ${isOverlay ? 'border-blue-500 shadow-2xl rotate-2 scale-105 z-50' : 'border-slate-200/60 shadow-sm'}`}>
      
      {/* O CABE√áALHO DA LISTA (Com a Al√ßa de Arrasto) */}
      <div className="p-4 border-b border-slate-200/60 bg-slate-100/50 flex justify-between items-start sticky top-0 z-10 min-h-[56px] group">
        
        <div className="flex-1 pr-2 flex items-start gap-1">
          {/* üî• A AL√áA MAGN√âTICA (Grip) que ativa o arraste da Coluna */}
          {!isRestricted && !isOverlay && (
            <div ref={setActivatorNodeRef} {...attributes} {...listeners} className="mt-0.5 text-slate-400 hover:text-blue-500 cursor-grab active:cursor-grabbing outline-none touch-none shrink-0 p-0.5 -ml-1.5 opacity-0 group-hover:opacity-100 transition-opacity" title="Arrastar Lista">
              <GripHorizontal size={18} />
            </div>
          )}

          <div className="flex-1">
            {isEditingTitle && !isRestricted && !isOverlay ? (
              <input autoFocus value={editTitle} onChange={(e) => setEditTitle(e.target.value)} onBlur={handleSaveTitle} onKeyDown={handleKeyDownTitle} className="w-full text-[15px] font-bold text-slate-800 tracking-tight leading-snug bg-white border border-blue-400 rounded px-1.5 py-0.5 -mx-1.5 outline-none shadow-sm" />
            ) : (
              <h3 onClick={() => !isRestricted && !isOverlay && setIsEditingTitle(true)} className={`font-bold text-slate-700 tracking-tight leading-snug text-[15px] break-words whitespace-pre-wrap ${!isRestricted ? 'cursor-text hover:bg-slate-200/70 hover:text-slate-900 rounded px-1.5 py-0.5 -mx-1.5 transition-colors' : 'cursor-default'}`} title={!isRestricted ? "Clique para renomear" : ""}>
                {column.title}
              </h3>
            )}
          </div>
        </div>
        
        <span className="bg-white text-slate-500 text-[11px] font-bold px-2 py-0.5 rounded-full shadow-sm border border-slate-200 shrink-0 mt-0.5">{tasks.length}</span>
      </div>
      
      {/* O CORPO DOS CART√ïES */}
      <div className="p-3 flex-1 overflow-y-auto scrollbar-thin scrollbar-thumb-slate-300 min-h-[150px]">
        {/* Desabilitamos o SortableContext vertical se for overlay para evitar bugs */}
        {!isOverlay ? (
          <SortableContext items={tasks.map((t: any) => t.id)} strategy={verticalListSortingStrategy}>
            <div className="flex flex-col gap-0 pb-2">
              {tasks.map((task: any) => (
                <TaskCard key={task.id} task={task} isRestricted={isRestricted} userId={userId} />
              ))}
            </div>
          </SortableContext>
        ) : (
          <div className="flex flex-col gap-0 pb-2">
            {tasks.map((task: any) => (
              <TaskCard key={task.id} task={task} isRestricted={isRestricted} userId={userId} />
            ))}
          </div>
        )}
        
        {!isRestricted && !isOverlay && (
          <div className="mt-1">
            {isAddingTask ? (
              <div className="bg-white p-3 rounded-xl border border-blue-400 shadow-md transform transition-all">
                <textarea autoFocus value={newTaskTitle} onChange={(e) => setNewTaskTitle(e.target.value)} onBlur={handleSaveTask} onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleSaveTask(); } if (e.key === 'Escape') setIsAddingTask(false); }} placeholder="O que precisa ser feito?" className="w-full text-sm font-medium text-slate-800 bg-transparent outline-none resize-none overflow-hidden leading-snug placeholder:text-slate-400 placeholder:font-normal" rows={2} />
              </div>
            ) : (
              <button onClick={() => setIsAddingTask(true)} className="w-full flex items-center gap-2 py-2.5 px-3 text-sm font-semibold text-slate-500 hover:text-blue-600 hover:bg-white rounded-xl transition-all border border-transparent hover:border-blue-200 hover:shadow-sm">
                <Plus size={16} /> Adicionar Cart√£o
              </button>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
EOF

echo "üé® 3. Frontend: Habilitando o Drag & Drop Bidimensional (Quadro Inteiro)..."

cat << 'EOF' > apps/web/src/components/board/Board.tsx
import { useState, useEffect } from 'react';
import { DndContext, DragOverlay, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, defaultDropAnimationSideEffects } from '@dnd-kit/core';
import { SortableContext, arrayMove, sortableKeyboardCoordinates, horizontalListSortingStrategy } from '@dnd-kit/sortable';
import { Column } from './Column';
import { TaskCard } from './TaskCard';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import toast from 'react-hot-toast';
import { socket } from '@/lib/socket';

export function Board({ initialData }: { initialData: any }) {
  const queryClient = useQueryClient();
  const [columns, setColumns] = useState(initialData?.columns || []);
  
  // üî• O React precisa saber se estamos segurando um Cart√£o ou a Lista Gigante:
  const [activeTask, setActiveTask] = useState<any>(null);
  const [activeColumn, setActiveColumn] = useState<any>(null);

  const { data: user } = useQuery({ queryKey: ['me'], queryFn: async () => (await api.get('/me')).data.user });
  const userId = user?.id;

  const { data: boardData } = useQuery({
    queryKey: ['board', initialData.id],
    queryFn: async () => (await api.get(`/kanban/board/${initialData.id}`)).data,
    initialData: initialData,
  });

  const isRestricted = boardData?.userRole === 'RESTRICTED';

  useEffect(() => { if (boardData?.columns) setColumns(boardData.columns); }, [boardData]);

  useEffect(() => {
    socket.connect();
    socket.on('boardUpdated', (data) => { if (data.boardId === initialData.id) queryClient.invalidateQueries({ queryKey: ['board', initialData.id] }); });
    return () => { socket.off('boardUpdated'); };
  }, [initialData.id, queryClient]);

  const updateTaskPosition = useMutation({
    mutationFn: async ({ taskId, columnId, order }: any) => await api.patch(`/kanban/tasks/${taskId}`, { columnId, order }),
    onError: (err: any) => { toast.error(err.response?.data?.message || 'Acesso negado.'); queryClient.invalidateQueries({ queryKey: ['board', initialData.id] }); }
  });

  // üî• O NOVO MUTATION PARA A API DE ORDEM DAS LISTAS
  const updateColumnPosition = useMutation({
    mutationFn: async ({ columnId, order }: any) => await api.patch(`/kanban/columns/${columnId}`, { order }),
    onError: (err: any) => { toast.error(err.response?.data?.message || 'Erro ao mover lista.'); queryClient.invalidateQueries({ queryKey: ['board', initialData.id] }); }
  });

  const createColumnMutation = useMutation({
    mutationFn: async (title: string) => await api.post('/kanban/columns', { title, boardId: initialData.id, order: columns.length }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['board', initialData.id] })
  });

  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 5 } }), 
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const handleDragStart = (event: any) => {
    const { active } = event;
    const type = active.data.current?.type;

    // A nossa Intelig√™ncia: Quem o usu√°rio pegou?
    if (type === 'Column') {
      setActiveColumn(active.data.current.column);
      return;
    }
    if (type === 'Task') {
      const col = columns.find((c: any) => c.tasks.some((t: any) => t.id === active.id));
      setActiveTask(col?.tasks.find((t: any) => t.id === active.id));
      return;
    }
  };

  const handleDragOver = (event: any) => {
    const { active, over } = event;
    if (!over || active.id === over.id) return;

    const isActiveTask = active.data.current?.type === 'Task';
    const isOverTaskOrColumn = over.data.current?.type === 'Task' || over.data.current?.type === 'Column';

    // S√≥ reordenamos visualmente no eixo X entre colunas se for uma TAREFA voando.
    // Listas n√£o saltam entre listas no evento de over, elas empurram umas √†s outras no end.
    if (!isActiveTask) return;

    const activeId = active.id;
    const overId = over.id;

    const activeColIndex = columns.findIndex((c: any) => c.tasks.some((t: any) => t.id === activeId));
    let overColIndex = -1;
    
    if (over.data.current?.type === 'Task') {
      overColIndex = columns.findIndex((c: any) => c.tasks.some((t: any) => t.id === overId));
    } else if (over.data.current?.type === 'Column') {
      overColIndex = columns.findIndex((c: any) => c.id === overId);
    }

    if (activeColIndex === -1 || overColIndex === -1 || activeColIndex === overColIndex) return;

    setColumns((prev: any) => {
      const activeCol = prev[activeColIndex];
      const overCol = prev[overColIndex];
      const taskIndex = activeCol.tasks.findIndex((t: any) => t.id === activeId);
      const task = activeCol.tasks[taskIndex];

      return prev.map((c: any, i: number) => {
        if (i === activeColIndex) return { ...c, tasks: c.tasks.filter((t: any) => t.id !== activeId) };
        if (i === overColIndex) {
          const overTaskIndex = over.data.current?.type === 'Task' ? overCol.tasks.findIndex((t: any) => t.id === overId) : overCol.tasks.length;
          const newIndex = overTaskIndex >= 0 ? overTaskIndex : overCol.tasks.length;
          const newTasks = [...overCol.tasks];
          newTasks.splice(newIndex, 0, { ...task, columnId: overCol.id });
          return { ...c, tasks: newTasks };
        }
        return c;
      });
    });
  };

  const handleDragEnd = (event: any) => {
    setActiveTask(null);
    setActiveColumn(null);
    
    const { active, over } = event;
    if (!over) return;

    const activeType = active.data.current?.type;

    // üî• O SHOW HORIZONTAL (Movendo a Coluna)
    if (activeType === 'Column') {
      const activeId = active.id;
      const overId = over.id;

      const activeColIndex = columns.findIndex((c: any) => c.id === activeId);
      const overColIndex = columns.findIndex((c: any) => c.id === overId);

      if (activeColIndex !== overColIndex && activeColIndex !== -1 && overColIndex !== -1) {
        let newCols = arrayMove(columns, activeColIndex, overColIndex);
        
        // O Ponto M√©dio Fracionado para Listas (Postgres)
        let newOrder = 0;
        const prevCol = newCols[overColIndex - 1];
        const nextCol = newCols[overColIndex + 1];

        if (prevCol && nextCol) newOrder = (prevCol.order + nextCol.order) / 2.0;
        else if (prevCol) newOrder = prevCol.order + 1.0;
        else if (nextCol) newOrder = nextCol.order / 2.0;
        else newOrder = 1.0;

        newCols[overColIndex] = { ...newCols[overColIndex], order: newOrder };
        setColumns(newCols);
        updateColumnPosition.mutate({ columnId: active.id, order: newOrder });
      }
      return;
    }

    // O SHOW VERTICAL (Movendo a Tarefa - J√° estava Perfeito)
    if (activeType === 'Task') {
      const activeId = active.id;
      const overId = over.id;

      const activeColIndex = columns.findIndex((c: any) => c.tasks.some((t: any) => t.id === activeId));
      if (activeColIndex === -1) return;

      const activeCol = columns[activeColIndex];
      const taskIndex = activeCol.tasks.findIndex((t: any) => t.id === activeId);
      const task = activeCol.tasks[taskIndex];

      if (isRestricted && task.assignedTo !== userId) {
        toast.error("Acesso Restrito: Apenas o respons√°vel pode mover a tarefa.");
        queryClient.invalidateQueries({ queryKey: ['board', initialData.id] });
        return;
      }

      const overColIndex = columns.findIndex((c: any) => c.id === overId || c.tasks.some((t: any) => t.id === overId));
      if (overColIndex === -1) return;
      
      const overCol = columns[overColIndex];
      let overTaskIndex = overCol.tasks.findIndex((t: any) => t.id === overId);

      let targetTasks = [...activeCol.tasks];
      let finalIndex = taskIndex;

      if (activeColIndex === overColIndex) {
        if (overTaskIndex !== -1 && taskIndex !== overTaskIndex) {
          finalIndex = overTaskIndex;
          targetTasks = arrayMove(activeCol.tasks, taskIndex, overTaskIndex);
        } else if (overId === overCol.id && taskIndex !== activeCol.tasks.length - 1) {
          finalIndex = activeCol.tasks.length - 1; 
          targetTasks = arrayMove(activeCol.tasks, taskIndex, finalIndex);
        }
      }

      let newOrder = 0;
      const prevTask = targetTasks[finalIndex - 1];
      const nextTask = targetTasks[finalIndex + 1];

      if (prevTask && nextTask) newOrder = (prevTask.order + nextTask.order) / 2.0; 
      else if (prevTask) newOrder = prevTask.order + 1.0; 
      else if (nextTask) newOrder = nextTask.order / 2.0; 
      else newOrder = 1.0; 

      setColumns((prev: any) => {
        const newCols = [...prev];
        newCols[activeColIndex].tasks = targetTasks;
        newCols[activeColIndex].tasks[finalIndex] = { ...task, order: newOrder };
        return newCols;
      });

      updateTaskPosition.mutate({ taskId: activeId, columnId: activeCol.id, order: newOrder });
    }
  };

  const handleAddColumn = () => {
    const title = prompt('Nome da nova etapa:');
    if (title) createColumnMutation.mutate(title);
  };

  const dropAnimation = { sideEffects: defaultDropAnimationSideEffects({ styles: { active: { opacity: '0.4' } } }) };

  return (
    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragStart={handleDragStart} onDragOver={handleDragOver} onDragEnd={handleDragEnd}>
      <div className="flex gap-6 h-full pb-4 items-start">
        {/* üî• Envelopamos as colunas num Contexto Horizontal */}
        <SortableContext items={columns.map((c: any) => c.id)} strategy={horizontalListSortingStrategy}>
          {columns.map((col: any) => (
            <Column key={col.id} column={col} tasks={col.tasks} isRestricted={isRestricted} userId={userId as string} />
          ))}
        </SortableContext>
        
        {!isRestricted && (
          <div className="w-80 shrink-0">
            <button onClick={handleAddColumn} disabled={createColumnMutation.isPending} className="w-full flex items-center justify-center gap-2 py-4 border-2 border-dashed border-slate-300 rounded-2xl text-slate-500 hover:text-blue-600 hover:border-blue-400 hover:bg-blue-50/50 transition-all font-semibold shadow-sm bg-white/50 backdrop-blur-sm">
              {createColumnMutation.isPending ? 'Criando...' : '+ Criar Nova Lista'}
            </button>
          </div>
        )}
      </div>
      <DragOverlay dropAnimation={dropAnimation}>
        {activeTask ? <TaskCard task={activeTask} isRestricted={isRestricted} userId={userId as string} isOverlay /> : null}
        {activeColumn ? <Column column={activeColumn} tasks={activeColumn.tasks} isRestricted={isRestricted} userId={userId as string} isOverlay /> : null}
      </DragOverlay>
    </DndContext>
  );
}
EOF

echo "üöÄ 4. Recompilando o Ecossistema..."
cd apps/api && pnpm run build
cd ../web && pnpm run build
cd ../..

echo "‚úÖ=========================================================="
echo "üéØ DRAG & DROP BIDIMENSIONAL EST√Å NO AR!"
echo "‚úÖ=========================================================="