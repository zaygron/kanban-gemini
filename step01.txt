#!/bin/bash
set -e

echo "üöÄ Iniciando Step 01: Setup do Monorepo & Core Contracts (@kanban/shared)..."

# 1. Setup Root
if [ ! -d ".git" ]; then
  git init
fi

cat << 'EOF' > pnpm-workspace.yaml
packages:
  - "apps/*"
  - "packages/*"
EOF

cat << 'EOF' > package.json
{
  "name": "kanban-monorepo",
  "private": true,
  "engines": {
    "node": ">=20"
  },
  "scripts": {
    "test": "pnpm -r test",
    "typecheck": "pnpm -r typecheck",
    "build": "pnpm -r build"
  }
}
EOF

cat << 'EOF' > .gitignore
node_modules
dist
.env
.DS_Store
coverage
EOF

# 2. Setup apps e packages base
mkdir -p apps/web apps/api packages/shared/src/__tests__

cat << 'EOF' > apps/web/package.json
{
  "name": "web",
  "version": "1.0.0",
  "private": true
}
EOF

cat << 'EOF' > apps/api/package.json
{
  "name": "api",
  "version": "1.0.0",
  "private": true
}
EOF

# 3. Setup do pacote shared
cat << 'EOF' > packages/shared/package.json
{
  "name": "@kanban/shared",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "typecheck": "tsc --noEmit",
    "test": "vitest run"
  },
  "dependencies": {
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "typescript": "^5.3.3",
    "vitest": "^1.3.1",
    "@types/node": "^20.0.0"
  }
}
EOF

cat << 'EOF' > packages/shared/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "CommonJS",
    "declaration": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"]
}
EOF

# 4. M√≥dulo de Rank Lexicogr√°fico (Algoritmo Pr√≥prio, Limpo e Eficiente)
cat << 'EOF' > packages/shared/src/rank.ts
const MIN_CHAR = 33; // '!' (Menor caractere print√°vel)
const MAX_CHAR = 126; // '~' (Maior caractere print√°vel)

export function rankInitial(): string {
  return String.fromCharCode(MIN_CHAR + Math.floor((MAX_CHAR - MIN_CHAR) / 2));
}

export function rankBetween(before: string | null, after: string | null): string {
  const p = before || String.fromCharCode(MIN_CHAR);
  const n = after || String.fromCharCode(MAX_CHAR + 1);

  if (p >= n) {
    throw new Error('before rank must be strictly less than after rank');
  }

  let rank = '';
  let i = 0;

  while (true) {
    const pChar = i < p.length ? p.charCodeAt(i) : MIN_CHAR;
    const nChar = i < n.length ? n.charCodeAt(i) : MAX_CHAR + 1;

    if (pChar === nChar) {
      rank += String.fromCharCode(pChar);
      i++;
      continue;
    }

    const mid = Math.floor((pChar + nChar) / 2);

    if (mid === pChar) {
      rank += String.fromCharCode(pChar);
      i++;
    } else {
      rank += String.fromCharCode(mid);
      break;
    }
  }

  return rank;
}
EOF

# 5. Testes Unit√°rios do Rank (Obrigat√≥rios pela spec)
cat << 'EOF' > packages/shared/src/__tests__/rank.spec.ts
import { describe, it, expect } from 'vitest';
import { rankInitial, rankBetween } from '../rank';

describe('Ranking Module', () => {
  it('deve gerar um rank inicial', () => {
    const r = rankInitial();
    expect(typeof r).toBe('string');
    expect(r.length).toBeGreaterThan(0);
  });

  it('deve inserir no inicio (before=null, after=firstRank)', () => {
    const firstRank = rankInitial();
    const newRank = rankBetween(null, firstRank);
    expect(newRank < firstRank).toBe(true);
  });

  it('deve inserir no fim (before=lastRank, after=null)', () => {
    const lastRank = rankInitial();
    const newRank = rankBetween(lastRank, null);
    expect(newRank > lastRank).toBe(true);
  });

  it('deve inserir no meio e manter ordem lexicogr√°fica', () => {
    const before = 'A';
    const after = 'C';
    const newRank = rankBetween(before, after);
    expect(newRank > before).toBe(true);
    expect(newRank < after).toBe(true);
  });

  it('deve suportar 50 insercoes consecutivas no MESMO GAP sem falhar (Teste de Estresse)', () => {
    let before = 'A';
    const after = 'B';
    const ranks: string[] = [];

    for (let i = 0; i < 50; i++) {
      const newRank = rankBetween(before, after);
      expect(newRank > before).toBe(true);
      expect(newRank < after).toBe(true);
      ranks.push(newRank);
      before = newRank; // always insert after the newly created rank (pushing limits)
    }

    // Ensure strict lexicographical order is maintained
    for (let i = 0; i < ranks.length - 1; i++) {
      expect(ranks[i] < ranks[i+1]).toBe(true);
    }
  });

  it('deve lancar erro se before >= after', () => {
    expect(() => rankBetween('C', 'A')).toThrow();
    expect(() => rankBetween('A', 'A')).toThrow();
  });
});
EOF

# 6. Contratos Zod (Source of Truth)
cat << 'EOF' > packages/shared/src/contracts.ts
import { z } from 'zod';

// ==================== ENTIDADES DE DOM√çNIO ====================
export const UserSchema = z.object({
  id: z.string().uuid(),
  email: z.string().email(),
  name: z.string(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional()
});

export const BoardSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  createdBy: z.string().uuid(),
  archivedAt: z.string().datetime().nullable().optional(),
  version: z.number().int(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional()
});

export const MembershipSchema = z.object({
  id: z.string().uuid(),
  boardId: z.string().uuid(),
  userId: z.string().uuid(),
  role: z.enum(['owner', 'member', 'viewer']),
  revokedAt: z.string().datetime().nullable().optional(),
  createdAt: z.string().datetime().optional()
});

export const ListSchema = z.object({
  id: z.string().uuid(),
  boardId: z.string().uuid(),
  title: z.string(),
  rank: z.string(),
  archivedAt: z.string().datetime().nullable().optional(),
  version: z.number().int(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional()
});

export const CardSchema = z.object({
  id: z.string().uuid(),
  boardId: z.string().uuid(),
  listId: z.string().uuid(),
  title: z.string(),
  description: z.string().nullable().optional(),
  status: z.string(),
  assignedTo: z.string().uuid().nullable().optional(),
  rank: z.string(),
  createdBy: z.string().uuid(),
  archivedAt: z.string().datetime().nullable().optional(),
  version: z.number().int(),
  createdAt: z.string().datetime().optional(),
  updatedAt: z.string().datetime().optional()
});

export const CommentSchema = z.object({
  id: z.string().uuid(),
  cardId: z.string().uuid(),
  authorId: z.string().uuid(),
  body: z.string(),
  archivedAt: z.string().datetime().nullable().optional(),
  createdAt: z.string().datetime().optional()
});

// ==================== DTOs REST ====================
export const LoginRequestSchema = z.object({
  email: z.string().email(),
  password: z.string()
});

export const CreateBoardRequestSchema = z.object({
  name: z.string().min(1)
});

export const CreateListRequestSchema = z.object({
  title: z.string().min(1),
  beforeListId: z.string().uuid().optional(),
  afterListId: z.string().uuid().optional()
});

export const CreateCardRequestSchema = z.object({
  title: z.string().min(1),
  description: z.string().optional(),
  beforeCardId: z.string().uuid().optional(),
  afterCardId: z.string().uuid().optional()
});

export const MoveCardRequestSchema = z.object({
  toListId: z.string().uuid(),
  beforeCardId: z.string().uuid().optional(),
  afterCardId: z.string().uuid().optional(),
  clientRequestId: z.string().uuid(),
  baseCardVersion: z.number().int().optional()
});

// ==================== EVENTOS WEBSOCKET ====================
export const BaseWsEventSchema = z.object({
  eventId: z.string().uuid(),
  boardId: z.string().uuid(),
  boardVersion: z.number().int(),
  actorUserId: z.string().uuid(),
  serverTime: z.string().datetime()
});

export const BoardSnapshotEventSchema = BaseWsEventSchema.extend({
  type: z.literal('board.snapshot'),
  board: BoardSchema,
  lists: z.array(ListSchema),
  cards: z.array(CardSchema),
  memberships: z.array(MembershipSchema)
});

export const ListCreatedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('list.created'),
  list: ListSchema
});

export const ListUpdatedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('list.updated'),
  list: ListSchema
});

export const ListArchivedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('list.archived'),
  listId: z.string().uuid(),
  archivedAt: z.string().datetime()
});

export const CardCreatedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('card.created'),
  card: CardSchema
});

export const CardUpdatedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('card.updated'),
  card: CardSchema
});

export const CardMovedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('card.moved'),
  cardId: z.string().uuid(),
  fromListId: z.string().uuid(),
  toListId: z.string().uuid(),
  newRank: z.string(),
  cardVersion: z.number().int()
});

export const CardArchivedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('card.archived'),
  cardId: z.string().uuid(),
  archivedAt: z.string().datetime()
});

export const CommentCreatedEventSchema = BaseWsEventSchema.extend({
  type: z.literal('comment.created'),
  comment: CommentSchema
});

// Tipos Inferidos
export type User = z.infer<typeof UserSchema>;
export type Board = z.infer<typeof BoardSchema>;
export type Membership = z.infer<typeof MembershipSchema>;
export type List = z.infer<typeof ListSchema>;
export type Card = z.infer<typeof CardSchema>;
export type Comment = z.infer<typeof CommentSchema>;
EOF

cat << 'EOF' > packages/shared/src/index.ts
export * from './rank';
export * from './contracts';
EOF

# 7. Executa valida√ß√µes e Build
echo "üì¶ Instalando depend√™ncias..."
pnpm install

echo "‚úÖ Executando Typecheck..."
pnpm run typecheck

echo "üß™ Executando testes unit√°rios do M√≥dulo de Ranking..."
pnpm run test

echo "üèóÔ∏è Executando Build..."
pnpm run build

# 8. Cria o commit inicial
git add .
git commit -m "feat(step-01): setup monorepo, shared contracts and rank module"

echo ""
echo "‚úÖ=========================================================="
echo "üéØ STEP 01 CONCLU√çDO COM SUCESSO!"
echo "Testes unit√°rios passaram, regras validadas e build pronto."
echo "‚úÖ=========================================================="