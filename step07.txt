#!/bin/bash
set -e

echo "üöÄ Iniciando Step 07: Seguran√ßa de Produ√ß√£o, UX e Polimento Final..."

# ==========================================
# 1. BLINDANDO A SEGURAN√áA NO BACKEND (API)
# ==========================================
echo "üîí Recriando o Guardi√£o de Seguran√ßa (Cookie JWT) no Backend..."

mkdir -p apps/api/src/auth

cat << 'EOF' > apps/api/src/auth/kanban.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class KanbanGuard implements CanActivate {
  // Instanciamos diretamente para evitar conflitos de Inje√ß√£o de Depend√™ncia
  private jwtService = new JwtService({ secret: process.env.JWT_SECRET || 'super_secret_kanban_key_2026' });

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    
    // Extrai o cookie 'Authentication' injetado no momento do Login
    const token = request.cookies?.Authentication;

    if (!token) {
      throw new UnauthorizedException('Acesso negado: Voc√™ n√£o est√° logado na API.');
    }

    try {
      // Valida a assinatura criptogr√°fica do Token
      const payload = await this.jwtService.verifyAsync(token);
      
      // Injeta o usu√°rio validado na requisi√ß√£o para a Controller utilizar
      request.user = payload;
      return true;
    } catch {
      throw new UnauthorizedException('Acesso negado: Sess√£o inv√°lida ou expirada.');
    }
  }
}
EOF

# Aplicando o Guardi√£o na Controller e adicionando Rota de Delete
cat << 'EOF' > apps/api/src/kanban/kanban.controller.ts
import { Controller, Get, Post, Body, Patch, Param, Delete, Request, UseGuards } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { EventsGateway } from '../events/events.gateway';
import { KanbanGuard } from '../auth/kanban.guard';

function toRank(order: number): string {
  return Number(order || 0).toFixed(5).padStart(20, '0');
}

// üîê TODA A API AGORA EST√Å 100% BLINDADA E PROTEGIDA!
@UseGuards(KanbanGuard)
@Controller('kanban')
export class KanbanController {
  constructor(private prisma: PrismaService, private events: EventsGateway) {}

  @Get('board/:id')
  async getBoard(@Param('id') id: string) {
    const board = await this.prisma.board.findUnique({
      where: { id },
      include: {
        lists: { include: { cards: { orderBy: { rank: 'asc' } } }, orderBy: { rank: 'asc' } }
      }
    });

    if (!board) return null;

    return {
      ...board,
      columns: board.lists.map((list: any) => ({
        id: list.id,
        title: list.title,
        order: parseFloat(list.rank),
        boardId: list.boardId,
        tasks: list.cards.map((card: any) => ({
          id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId
        }))
      }))
    };
  }

  @Post('columns')
  async createColumn(@Body() body: { title: string; boardId: string; order: number }) {
    const list = await this.prisma.list.create({
      data: { title: body.title, boardId: body.boardId, rank: toRank(body.order) }
    });
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: list.id, title: list.title, order: parseFloat(list.rank), boardId: list.boardId };
  }

  @Post('tasks')
  async createTask(@Request() req: any, @Body() body: { title: string; columnId: string; order: number }) {
    const list = await this.prisma.list.findUnique({ where: { id: body.columnId } });
    if (!list) return null;

    // Fim da gambiarra! O ID do usu√°rio agora vem direto do Token Criptografado 100% Seguro
    const userId = req.user.sub || req.user.id; 

    const card = await this.prisma.card.create({
      data: { 
        title: body.title, 
        listId: body.columnId, 
        rank: toRank(body.order),
        boardId: list.boardId,
        createdById: userId,
        status: 'TODO'
      }
    });
    
    this.events.server.emit('boardUpdated', { boardId: list.boardId });
    return { id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId };
  }

  @Patch('tasks/:id')
  async updateTask(@Param('id') id: string, @Body() body: { columnId?: string; order?: number }) {
    const data: any = {};
    if (body.columnId) data.listId = body.columnId;
    if (body.order !== undefined) data.rank = toRank(body.order);

    const card = await this.prisma.card.update({ where: { id }, data });
    this.events.server.emit('boardUpdated', { boardId: card.boardId });
    return { id: card.id, title: card.title, order: parseFloat(card.rank), columnId: card.listId };
  }

  // NOVA ROTA: Deletar Cart√£o
  @Delete('tasks/:id')
  async deleteTask(@Param('id') id: string) {
    const card = await this.prisma.card.findUnique({ where: { id }});
    if (!card) return null;
    await this.prisma.card.delete({ where: { id } });
    this.events.server.emit('boardUpdated', { boardId: card.boardId });
    return { success: true };
  }
}
EOF

# ==========================================
# 2. FRONTEND: NOTIFICA√á√ïES (TOASTS) E LIXEIRA
# ==========================================
echo "üé® Atualizando o Frontend com Toasts e fun√ß√£o de exclus√£o..."
cd apps/web
pnpm add react-hot-toast

cat << 'EOF' > src/app/layout.tsx
import './globals.css';
import Providers from '../components/Providers';
import { Toaster } from 'react-hot-toast';

export const metadata = {
  title: 'Kanban v2',
  description: 'Sistema Kanban Colaborativo',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="pt-BR">
      <body>
        <Providers>
          {children}
          {/* Componente invis√≠vel que injeta as notifica√ß√µes elegantes */}
          <Toaster position="bottom-right" toastOptions={{ duration: 3000 }} />
        </Providers>
      </body>
    </html>
  );
}
EOF

cat << 'EOF' > src/components/board/TaskCard.tsx
import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { GripVertical, Trash2 } from 'lucide-react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import toast from 'react-hot-toast';

export function TaskCard({ task, isOverlay }: { task: any, isOverlay?: boolean }) {
  const queryClient = useQueryClient();
  const { setNodeRef, attributes, listeners, transform, transition, isDragging } = useSortable({
    id: task.id,
    data: { type: 'Task', task }
  });

  const deleteTaskMutation = useMutation({
    mutationFn: async () => {
      await api.delete(`/kanban/tasks/${task.id}`);
    },
    onSuccess: () => {
      toast.success('Tarefa exclu√≠da!');
      queryClient.invalidateQueries(); 
    },
    onError: () => toast.error('Erro ao excluir a tarefa.')
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging && !isOverlay ? 0.3 : 1,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`group bg-white p-3 rounded-xl shadow-sm border flex gap-2 items-start relative
        ${isOverlay ? 'border-blue-500 shadow-xl rotate-2 scale-105 z-50' : 'border-slate-200 hover:border-blue-300 mb-3'}
      `}
    >
      <div {...attributes} {...listeners} className="mt-0.5 text-slate-300 hover:text-blue-500 cursor-grab active:cursor-grabbing outline-none touch-none">
        <GripVertical size={16} />
      </div>
      
      <div className="flex-1 pr-6">
        <p className="text-sm font-medium text-slate-800 leading-snug break-words">{task.title}</p>
      </div>

      {!isOverlay && (
        <button 
          onClick={(e) => { 
            e.stopPropagation(); 
            if (confirm('Tem certeza que deseja excluir esta tarefa?')) deleteTaskMutation.mutate(); 
          }}
          className="absolute right-2 top-3 text-slate-300 hover:text-red-500 hover:bg-red-50 p-1.5 rounded-md transition-colors opacity-0 group-hover:opacity-100"
          title="Excluir Tarefa"
        >
          <Trash2 size={14} />
        </button>
      )}
    </div>
  );
}
EOF

cat << 'EOF' > src/components/board/Column.tsx
import { useDroppable } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { TaskCard } from './TaskCard';
import { useState } from 'react';
import { Plus } from 'lucide-react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import toast from 'react-hot-toast';

export function Column({ column, boardId }: { column: any, boardId: string }) {
  const { setNodeRef } = useDroppable({ id: column.id, data: { type: 'Column', column } });
  const [isAdding, setIsAdding] = useState(false);
  const [title, setTitle] = useState('');
  const queryClient = useQueryClient();

  const addTaskMutation = useMutation({
    mutationFn: async (t: string) => {
      const order = column.tasks?.length > 0 ? column.tasks[column.tasks.length - 1].order + 1000 : 1000;
      await api.post('/kanban/tasks', { title: t, columnId: column.id, order });
    },
    onSuccess: () => { 
      toast.success('Tarefa criada!');
      queryClient.invalidateQueries({ queryKey: ['board', boardId] }); 
      setIsAdding(false); 
      setTitle(''); 
    },
    onError: () => toast.error('Falha ao criar tarefa.')
  });

  return (
    <div className="bg-slate-100/90 rounded-2xl w-[320px] shrink-0 flex flex-col max-h-full border border-slate-200 shadow-sm">
      <div className="p-4 flex items-center justify-between border-b border-slate-200/60 bg-slate-100/50 rounded-t-2xl">
        <h3 className="font-semibold text-slate-800 tracking-tight">{column.title}</h3>
        <span className="bg-white border border-slate-200 text-slate-600 text-xs px-2 py-0.5 rounded-full font-bold">{column.tasks?.length || 0}</span>
      </div>
      <div ref={setNodeRef} className="flex-1 overflow-y-auto p-3 min-h-[150px] scrollbar-thin">
        <SortableContext items={(column.tasks || []).map((t: any) => t.id)} strategy={verticalListSortingStrategy}>
          {(column.tasks || []).map((task: any) => (
            <TaskCard key={task.id} task={task} />
          ))}
        </SortableContext>
        {isAdding ? (
          <form onSubmit={(e) => { e.preventDefault(); if (title.trim()) addTaskMutation.mutate(title); }} className="mt-1">
            <input autoFocus value={title} onChange={e => setTitle(e.target.value)} placeholder="O que ser√° feito?" className="w-full text-sm px-3 py-2.5 border border-slate-300 shadow-sm rounded-xl outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all" />
            <div className="flex gap-2 mt-2">
              <button type="submit" disabled={addTaskMutation.isPending} className="bg-blue-600 text-white text-xs px-4 py-2 rounded-lg hover:bg-blue-700 font-medium transition-colors">Salvar</button>
              <button type="button" onClick={() => setIsAdding(false)} className="text-slate-500 hover:text-slate-800 hover:bg-slate-200 text-xs px-3 py-2 rounded-lg font-medium transition-colors">Cancelar</button>
            </div>
          </form>
        ) : (
          <button onClick={() => setIsAdding(true)} className="flex items-center gap-2 text-sm text-slate-500 hover:text-slate-800 w-full p-2.5 hover:bg-slate-200/70 border border-dashed border-transparent hover:border-slate-300 rounded-xl transition-all mt-1 font-medium">
            <Plus size={18} /> Adicionar Cart√£o
          </button>
        )}
      </div>
    </div>
  );
}
EOF

# Atualizando o Board (Feedback na cria√ß√£o da lista)
cat << 'EOF' > src/components/board/Board.tsx
'use client';

import { useState, useEffect } from 'react';
import { DndContext, DragOverlay, closestCorners, PointerSensor, useSensor, useSensors, DragStartEvent, DragOverEvent, DragEndEvent } from '@dnd-kit/core';
import { arrayMove } from '@dnd-kit/sortable';
import { Column } from './Column';
import { TaskCard } from './TaskCard';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import { Plus } from 'lucide-react';
import { io } from 'socket.io-client';
import toast from 'react-hot-toast';

export function calcPos(prevOrder?: number, nextOrder?: number): number {
  if (prevOrder === undefined && nextOrder === undefined) return 1000;
  if (prevOrder === undefined) return nextOrder! / 2;
  if (nextOrder === undefined) return prevOrder! + 1000;
  return (prevOrder + nextOrder) / 2;
}

export function Board({ initialData }: { initialData: any }) {
  const [board, setBoard] = useState(initialData);
  const [activeTask, setActiveTask] = useState<any>(null);
  const queryClient = useQueryClient();

  useEffect(() => { setBoard(initialData); }, [initialData]);

  useEffect(() => {
    const socket = io('http://localhost:3001', { withCredentials: true, transports: ['websocket'] });
    socket.on('boardUpdated', () => queryClient.invalidateQueries({ queryKey: ['board', board.id] }));
    return () => { socket.disconnect(); };
  }, [board.id, queryClient]);

  const sensors = useSensors(useSensor(PointerSensor, { activationConstraint: { distance: 5 } }));

  const moveTaskMutation = useMutation({
    mutationFn: async ({ taskId, data }: { taskId: string; data: any }) => {
      await api.patch(`/kanban/tasks/${taskId}`, data);
    },
    onError: () => {
      toast.error('Erro de conex√£o ao salvar movimento.');
      queryClient.invalidateQueries({ queryKey: ['board', board.id] });
    },
    onSettled: () => queryClient.invalidateQueries({ queryKey: ['board', board.id] })
  });

  const addColumnMutation = useMutation({
    mutationFn: async (title: string) => {
      const order = board.columns?.length > 0 ? board.columns[board.columns.length - 1].order + 1000 : 1000;
      await api.post('/kanban/columns', { title, boardId: board.id, order });
    },
    onSuccess: () => {
      toast.success('Lista criada com sucesso!');
      queryClient.invalidateQueries({ queryKey: ['board', board.id] });
    },
    onError: () => toast.error('Falha ao criar nova lista.')
  });

  const handleDragStart = (e: DragStartEvent) => {
    if (e.active.data.current?.type === 'Task') setActiveTask(e.active.data.current.task);
  };

  const handleDragOver = (e: DragOverEvent) => {
    const { active, over } = e;
    if (!over || active.id === over.id || active.data.current?.type !== 'Task') return;

    const isOverColumn = over.data.current?.type === 'Column';

    setBoard((prev: any) => {
      const activeColIndex = (prev.columns || []).findIndex((col: any) => (col.tasks || []).some((t: any) => t.id === active.id));
      const overColIndex = isOverColumn 
        ? (prev.columns || []).findIndex((col: any) => col.id === over.id)
        : (prev.columns || []).findIndex((col: any) => (col.tasks || []).some((t: any) => t.id === over.id));

      if (activeColIndex === -1 || overColIndex === -1 || activeColIndex === overColIndex) return prev;

      const newCols = [...prev.columns];
      const taskObj = newCols[activeColIndex].tasks.find((t: any) => t.id === active.id);

      newCols[activeColIndex] = { ...newCols[activeColIndex], tasks: newCols[activeColIndex].tasks.filter((t: any) => t.id !== active.id) };
      
      const newOverTasks = [...newCols[overColIndex].tasks];
      if (isOverColumn) {
        newOverTasks.push({ ...taskObj, columnId: newCols[overColIndex].id });
      } else {
        const overTaskIndex = newOverTasks.findIndex((t: any) => t.id === over.id);
        const modifier = (over && active.rect.current.translated && active.rect.current.translated.top > over.rect.top + over.rect.height) ? 1 : 0;
        newOverTasks.splice(overTaskIndex + modifier, 0, { ...taskObj, columnId: newCols[overColIndex].id });
      }
      newCols[overColIndex] = { ...newCols[overColIndex], tasks: newOverTasks };
      
      return { ...prev, columns: newCols };
    });
  };

  const handleDragEnd = (e: DragEndEvent) => {
    setActiveTask(null);
    const { active, over } = e;
    if (!over) return;

    const activeCol = (board.columns || []).find((col: any) => (col.tasks || []).some((t: any) => t.id === active.id));
    const overCol = (board.columns || []).find((col: any) => col.id === over.id) || (board.columns || []).find((col: any) => (col.tasks || []).some((t: any) => t.id === over.id));

    if (!activeCol || !overCol) return;

    let finalTasks = [...overCol.tasks];
    let newIndex = finalTasks.findIndex((t: any) => t.id === active.id);

    if (activeCol.id === overCol.id) {
       const oldIndex = finalTasks.findIndex((t: any) => t.id === active.id);
       const overIndex = finalTasks.findIndex((t: any) => t.id === over.id);
       if (oldIndex !== overIndex) {
           finalTasks = arrayMove(finalTasks, oldIndex, overIndex);
           newIndex = overIndex;
           setBoard((prev: any) => ({
             ...prev, columns: prev.columns.map((c: any) => c.id === overCol.id ? { ...c, tasks: finalTasks } : c)
           }));
       }
    }

    const targetTask = finalTasks[newIndex];
    if (!targetTask) return;

    const prevOrder = finalTasks[newIndex - 1]?.order;
    const nextOrder = finalTasks[newIndex + 1]?.order;
    const newOrder = calcPos(prevOrder, nextOrder);
    
    if (activeCol.id !== overCol.id || newOrder !== targetTask.order) {
       moveTaskMutation.mutate({ taskId: active.id as string, data: { columnId: overCol.id, order: newOrder } });
    }
  };

  return (
    <DndContext sensors={sensors} collisionDetection={closestCorners} onDragStart={handleDragStart} onDragOver={handleDragOver} onDragEnd={handleDragEnd}>
      <div className="flex gap-6 h-full items-start overflow-x-auto pb-4">
        {(board.columns || []).map((col: any) => (
          <Column key={col.id} column={col} boardId={board.id} />
        ))}
        <button 
          onClick={() => { const t = prompt('Nome da Nova Lista:'); if(t && t.trim()) addColumnMutation.mutate(t); }}
          className="shrink-0 w-80 bg-slate-200/50 hover:bg-white border-2 border-dashed border-slate-300 hover:border-blue-400 hover:text-blue-600 rounded-2xl flex items-center justify-center gap-2 text-slate-500 font-medium transition-all h-[100px]"
        >
          <Plus size={20} /> Criar Nova Lista
        </button>
      </div>
      <DragOverlay>
        {activeTask ? <TaskCard task={activeTask} isOverlay /> : null}
      </DragOverlay>
    </DndContext>
  );
}
EOF

# ==========================================
# 3. BUILD FINAL E COMMIT
# ==========================================
cd ../..
echo "üèóÔ∏è Recompilando Todo o Monorepo (Definition of Done)..."
cd apps/api && pnpm run build
cd ../web && pnpm run build
cd ../..

git config core.filemode false || true
git add .
git commit -m "feat: final polish, API security locked and UX toasts" || true

echo ""
echo "‚úÖ=========================================================="
echo "üéØ SISTEMA KANBAN 100% FINALIZADO, SEGURO E PRONTO PARA PROD!"
echo "Backend Trancado. Front Polido. Sincroniza√ß√£o em Tempo Real Ativa."
echo "‚úÖ=========================================================="