#!/bin/bash
set -e

echo "ðŸ§² 1. Frontend: Injetando a FÃ­sica MagnÃ©tica e a MatemÃ¡tica de FraÃ§Ãµes..."

cat << 'EOF' > apps/web/src/components/board/Board.tsx
import { useState, useEffect } from 'react';
// ðŸ”¥ Trocamos closestCorners por closestCenter para atraÃ§Ã£o magnÃ©tica perfeita
import { DndContext, DragOverlay, closestCenter, KeyboardSensor, PointerSensor, useSensor, useSensors, defaultDropAnimationSideEffects } from '@dnd-kit/core';
import { SortableContext, arrayMove, sortableKeyboardCoordinates, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { Column } from './Column';
import { TaskCard } from './TaskCard';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { api } from '@/lib/api';
import toast from 'react-hot-toast';
import { socket } from '@/lib/socket';

export function Board({ initialData }: { initialData: any }) {
  const queryClient = useQueryClient();
  const [columns, setColumns] = useState(initialData?.columns || []);
  const [activeTask, setActiveTask] = useState<any>(null);

  const { data: user } = useQuery({ queryKey: ['me'], queryFn: async () => (await api.get('/me')).data.user });
  const userId = user?.id;

  const { data: boardData } = useQuery({
    queryKey: ['board', initialData.id],
    queryFn: async () => (await api.get(`/kanban/board/${initialData.id}`)).data,
    initialData: initialData,
  });

  const isRestricted = boardData?.userRole === 'RESTRICTED';

  useEffect(() => { if (boardData?.columns) setColumns(boardData.columns); }, [boardData]);

  useEffect(() => {
    socket.connect();
    socket.on('boardUpdated', (data) => { if (data.boardId === initialData.id) queryClient.invalidateQueries({ queryKey: ['board', initialData.id] }); });
    return () => { socket.off('boardUpdated'); };
  }, [initialData.id, queryClient]);

  const updateTaskPosition = useMutation({
    mutationFn: async ({ taskId, columnId, order }: any) => await api.patch(`/kanban/tasks/${taskId}`, { columnId, order }),
    onError: (err: any) => {
      toast.error(err.response?.data?.message || 'Acesso negado.');
      queryClient.invalidateQueries({ queryKey: ['board', initialData.id] });
    }
  });

  const createColumnMutation = useMutation({
    mutationFn: async (title: string) => await api.post('/kanban/columns', { title, boardId: initialData.id, order: columns.length }),
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ['board', initialData.id] })
  });

  // Exigimos que o mouse ande 5px para ativar o arrasto (evita falhas ao clicar rÃ¡pido)
  const sensors = useSensors(
    useSensor(PointerSensor, { activationConstraint: { distance: 5 } }), 
    useSensor(KeyboardSensor, { coordinateGetter: sortableKeyboardCoordinates })
  );

  const handleDragStart = (event: any) => {
    const { active } = event;
    const col = columns.find((c: any) => c.tasks.some((t: any) => t.id === active.id));
    const task = col?.tasks.find((t: any) => t.id === active.id);
    setActiveTask(task);
  };

  const handleDragOver = (event: any) => {
    const { active, over } = event;
    if (!over || active.id === over.id) return;

    const activeId = active.id;
    const overId = over.id;

    const activeColIndex = columns.findIndex((c: any) => c.tasks.some((t: any) => t.id === activeId));
    const overColIndex = columns.findIndex((c: any) => c.id === overId || c.tasks.some((t: any) => t.id === overId));

    if (activeColIndex === -1 || overColIndex === -1 || activeColIndex === overColIndex) return;

    setColumns((prev: any) => {
      const activeCol = prev[activeColIndex];
      const overCol = prev[overColIndex];
      const taskIndex = activeCol.tasks.findIndex((t: any) => t.id === activeId);
      const task = activeCol.tasks[taskIndex];

      return prev.map((c: any, i: number) => {
        if (i === activeColIndex) return { ...c, tasks: c.tasks.filter((t: any) => t.id !== activeId) };
        if (i === overColIndex) {
          const overTaskIndex = overCol.tasks.findIndex((t: any) => t.id === overId);
          const newIndex = overTaskIndex >= 0 ? overTaskIndex : overCol.tasks.length;
          const newTasks = [...overCol.tasks];
          newTasks.splice(newIndex, 0, { ...task, columnId: overCol.id });
          return { ...c, tasks: newTasks };
        }
        return c;
      });
    });
  };

  const handleDragEnd = (event: any) => {
    setActiveTask(null);
    const { active, over } = event;
    if (!over) return;

    const activeId = active.id;
    const overId = over.id;

    const activeColIndex = columns.findIndex((c: any) => c.tasks.some((t: any) => t.id === activeId));
    if (activeColIndex === -1) return;

    const activeCol = columns[activeColIndex];
    const taskIndex = activeCol.tasks.findIndex((t: any) => t.id === activeId);
    const task = activeCol.tasks[taskIndex];

    if (isRestricted && task.assignedTo !== userId) {
      toast.error("Acesso Restrito: Apenas o responsÃ¡vel pode mover a tarefa.");
      queryClient.invalidateQueries({ queryKey: ['board', initialData.id] });
      return;
    }

    const overColIndex = columns.findIndex((c: any) => c.id === overId || c.tasks.some((t: any) => t.id === overId));
    if (overColIndex === -1) return;
    
    const overCol = columns[overColIndex];
    let overTaskIndex = overCol.tasks.findIndex((t: any) => t.id === overId);

    let targetTasks = [...activeCol.tasks];
    let finalIndex = taskIndex;

    // ðŸ”¥ O reordenamento visual acontece perfeitamente aqui
    if (activeColIndex === overColIndex) {
      if (overTaskIndex !== -1 && taskIndex !== overTaskIndex) {
        finalIndex = overTaskIndex;
        targetTasks = arrayMove(activeCol.tasks, taskIndex, overTaskIndex);
      } else if (overId === overCol.id && taskIndex !== activeCol.tasks.length - 1) {
        finalIndex = activeCol.tasks.length - 1; // Caiu no fundo vazio da lista
        targetTasks = arrayMove(activeCol.tasks, taskIndex, finalIndex);
      }
    }

    // ðŸª„ A MÃGICA DA MATEMÃTICA: O Ponto MÃ©dio Fracionado!
    let newOrder = 0;
    const prevTask = targetTasks[finalIndex - 1];
    const nextTask = targetTasks[finalIndex + 1];

    if (prevTask && nextTask) {
      newOrder = (prevTask.order + nextTask.order) / 2.0; // Ponto mÃ©dio exato entre dois cartÃµes
    } else if (prevTask) {
      newOrder = prevTask.order + 1.0; // PosiÃ§Ã£o Final da lista
    } else if (nextTask) {
      newOrder = nextTask.order / 2.0; // PosiÃ§Ã£o Inicial da lista (evita nÃºmeros negativos no banco)
    } else {
      newOrder = 1.0; // Lista estava vazia
    }

    // AtualizaÃ§Ã£o otimista na tela (Extremamente rÃ¡pido)
    setColumns((prev: any) => {
      const newCols = [...prev];
      newCols[activeColIndex].tasks = targetTasks;
      newCols[activeColIndex].tasks[finalIndex] = { ...task, order: newOrder };
      return newCols;
    });

    // Envia o nÃºmero decimal pro Postgres guardar para sempre!
    updateTaskPosition.mutate({ taskId: activeId, columnId: activeCol.id, order: newOrder });
  };

  const handleAddColumn = () => {
    const title = prompt('Nome da nova etapa:');
    if (title) createColumnMutation.mutate(title);
  };

  const dropAnimation = { sideEffects: defaultDropAnimationSideEffects({ styles: { active: { opacity: '0.4' } } }) };

  return (
    // ðŸ”¥ USAMOS closestCenter AQUI! O mouse agora dita as regras magnÃ©ticas.
    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragStart={handleDragStart} onDragOver={handleDragOver} onDragEnd={handleDragEnd}>
      <div className="flex gap-6 h-full pb-4 items-start">
        {columns.map((col: any) => (
          <Column key={col.id} column={col} tasks={col.tasks} isRestricted={isRestricted} userId={userId as string} />
        ))}
        {!isRestricted && (
          <div className="w-80 shrink-0">
            <button onClick={handleAddColumn} disabled={createColumnMutation.isPending} className="w-full flex items-center justify-center gap-2 py-4 border-2 border-dashed border-slate-300 rounded-2xl text-slate-500 hover:text-blue-600 hover:border-blue-400 hover:bg-blue-50/50 transition-all font-semibold shadow-sm bg-white/50 backdrop-blur-sm">
              {createColumnMutation.isPending ? 'Criando...' : '+ Criar Nova Lista'}
            </button>
          </div>
        )}
      </div>
      <DragOverlay dropAnimation={dropAnimation}>
        {activeTask ? <TaskCard task={activeTask} isRestricted={isRestricted} userId={userId as string} isOverlay /> : null}
      </DragOverlay>
    </DndContext>
  );
}
EOF

echo "ðŸš€ 2. Recompilando Todo o Frontend..."
cd apps/web && pnpm run build
cd ../..

echo "âœ…=========================================================="
echo "ðŸŽ¯ PROBLEMA RESOLVIDO! O ARRASTAR AGORA Ã‰ MAGNÃ‰TICO."
echo "âœ…=========================================================="